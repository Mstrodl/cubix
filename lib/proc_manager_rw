#!/usr/bin/env lua
--proc manager, the rewrite

--[[
    Process Manager:
        Primary: Manage Processes and running programs
        Secondary: manage /proc folder
]]

RELOADABLE = false

local libproc = {}

local processes = {}
local running = 0
local pid_last = 0

local old_run = os.run

local function killproc(p)
    process[p.pid] = nil
end

function __killallproc()
    if CUBIX_REBOOTING or CUBIX_TURNINGOFF then
        for pid,process in pairs(processes) do
            killproc(process)
        end
    else
        return ferror("proc.kapr: not rebooting or turningoff")
    end
end

Process = function(file)
    local self = {}
    pid_last = pid_last + 1

    self.pid = pid_last --PID of process
    self.file = file --File that the process represent
    self.parent = nil --Parent of process
    self.childs = {} --Its childs

    self.uid = -1 --The user(uid) that is running the process
    self.lineargs = '' --arguments to process
    self.user = ''
    self.tty = '' --TTY that is running the process

    os.debug.debug_write("[proc] new: "..self.file, false)
    return self
end

function run(self, arguments, pipe, env)
    --[[
        Actually run a process
    ]]

    permission.default() --set default permissions

    local cu = os.lib.login.currentUser()
    if not fs.verifyPerm(self.file, cu, 'x') then
        ferror("proc.run: perm error")
        return -1
    end

    running = self.pid
    processes[self.pid] = self

    old_run(env, self.file, unpack(arguments, 1))
end

--arguments : table
--parent : Process
--pipe : Pipe
--enviroment : table
local function run_itself(self, arguments, parent_proc, pipe, enviroment)
    --[[
        Run a process with its arguments, parent, pipe and defined enviroment
    ]]
    local _parent = nil
    if parent == nil then
        _parent = __init_process --making sure /sbin/init is parent of all processes(without parent)
    else
        _parent = parent
    end

    --default things
    if arguments == nil then arguments = {} end
    if enviroment == nil then enviroment = {} end

    --set parent and run process
    set_parent(self, _parent)
    run(self, arguments, pipe, enviroment)
end

function prexec(process, args, prt, pipe, env)
    return run_itself(process, args, prt, pipe, env)
end
_G['prexec'] = prexec

function set_parent(self, parent)
    self.parent = parent
    if parent ~= nil then
        parent.childs[ (#parent.childs) + 1 ] = self
    end
end

--CC os.run: use CBX processes but only recieve as CC os.run args
os.run = function(enviroment, executable, ...)
    local args = {...}
    local p = Process(executable)
    return run_itself(p, args, nil, nil, enviroment)
end

--os.runfile: use CBX processes with all possible arguments
os.runfile = function(executable, arguments, parent, pipe, env)
    local p = Process(executable)
    return run_itself(p, arguments, parent, pipe, env)
end

function get_processes()
    local c = deepcopy(processes)
    c['CPY_FLAG'] = true --copy flag
    return c
end

function get_running()
    return running
end
_G['pget_running'] = get_running

function get_by_pid(pid)
    --get a process by its PID(not of deepcopy, but the original process) with permission
    if permission.grantAccess(fs.perms.SYS)
     or processes[running].file == '/bin/cshell'
     or processes[running].file == '/sbin/login'
     or processes[running].file == '/sbin/kill'
     or processes[running].file == 'sbin/kill' then
        return processes[pid]
    else
        ferror("get_by_pid: perm error")
    end
end

--get itself as a process object
function get_itself()
    if permission.grantAccess(fs.perms.SYS)
     or processes[running].file == '/bin/cshell'
     or processes[running].file == '/sbin/login'
     or processes[running].file == '/sbin/kill'
     or processes[running].file == 'sbin/kill' then
        return processes[running]
    else
        ferror("get_itself: perm error")
    end
end

function fork(f)
    local p = Process(f)
    set_parent(p, processes[running])
    return p
end
_G['fork'] = fork

function kill(pid, sig)
    local p = process[pid]
    if p.uid == os.lib.login.userUID() or os.lib.login.userUID() == 0 then
        killproc(processes[pid])
    end
end

function check_proof(p)
    -- check if a process is a original one(not a copy)
    if p == processes[p.pid] then
        return true
    end
    return false
end
libproc.check_proof = check_proof

function libroutine()
    _G['new_process'] = Process
    _G['libproc'] = libproc
end
