#!/usr/bin/env lua
--proc manager, the rewrite

--[[
    Process Manager:
        Primary: Manage Processes and running programs
        Secondary: manage /proc folder
]]

RELOADABLE = false

local libproc = {}

local processes = {}
local running = 0
local pid_last = 0

local old_run = os.run

local function killproc(p)
    processes[p.pid] = -1
end

function __killallproc()
    if CUBIX_REBOOTING or CUBIX_TURNINGOFF then
        for pid,process in pairs(processes) do
            if process ~= -1 then
                killproc(process)
            end
        end
    else
        return ferror("proc.kapr: not rebooting or turningoff")
    end
end

Process = function(file)
    local self = {}
    pid_last = pid_last + 1

    self.pid = pid_last --PID of process
    self.file = file --File that the process represent
    self.parent = nil --Parent of process
    self.childs = {} --Its childs

    self.uid = -1 --The user(uid) that is running the process
    self.lineargs = '' --arguments to process
    self.user = ''
    self.tty = '' --TTY that is running the process

    os.debug.debug_write("[proc] new: "..self.file, false)
    return self
end

function run(self, arguments, pipe, env)
    --[[
        Actually run a process
    ]]

    permission.default() --set default permissions

    local cu = os.lib.login.currentUser()
    if not fs.verifyPerm(self.file, cu, 'x') then
        ferror("proc.run: perm error")
        return -1
    end

    running = self.pid
    processes[self.pid] = self

    local ctty = os.lib.tty.getcurrentTTY()
    if ctty == nil or ctty == {} or ctty == '' then
        self.tty = '/dev/ttde'
    else
        self.tty = ctty.id
    end

    env['program_pipe'] = pipe
    if type(pipe) == 'table' then
        env['write'] = function(a)
            pipe:write(a)
        end
        env['print'] = function(a)
            pipe:write(a..'\n')
        end
        env['read'] = function()
            return pipe:readLine()
        end
    end
    old_run(env, self.file, unpack(arguments, 1))

    killproc(self)
end

--arguments : table
--parent : Process
--pipe : Pipe
--enviroment : table
local function run_itself(self, arguments, parent_proc, pipe, enviroment)
    --[[
        Run a process with its arguments, parent, pipe and defined enviroment
    ]]
    local _parent = nil
    print(self.parent)
    if self.parent == nil and self.file ~= '/sbin/init' then
        _parent = os.__init_process --making sure /sbin/init is parent of all processes(without parent)
    else
        _parent = parent_proc
    end

    --default things
    if arguments == nil then arguments = {} end
    if enviroment == nil then enviroment = {} end

    local line_args = ''
    for k,v in ipairs(arguments) do
        line_args = line_args .. v .. ' '
    end
    self.lineargs = line_args

    --set parent and run process
    set_parent(self, _parent)
    run(self, arguments, pipe, enviroment)
end

function prexec(process, args, prt, pipe, env)
    return run_itself(process, args, prt, pipe, env)
end
_G['prexec'] = prexec

function set_parent(self, parent)
    if parent ~= nil and type(parent) == 'table' then
        --get parent from file
        self.parent = parent.file
        parent.childs[ (#parent.childs) + 1 ] = self
    else
        self.parent = nil
        os.debug.debug_write("[proc] parent nil: "..self.file, false)
    end
end

--CC os.run: use CBX processes but only recieve as CC os.run args
os.run = function(enviroment, executable, ...)
    local args = {...}
    local p = Process(executable)
    return run_itself(p, args, nil, nil, enviroment)
end

--os.runfile: use CBX processes with all possible arguments
os.runfile = function(executable, arguments, parent, pipe, env)
    local p = Process(executable)
    return run_itself(p, arguments, parent, pipe, env)
end

function get_processes()
    return deepcopy(processes)
end

function get_running()
    return running
end
_G['pget_running'] = get_running

function get_by_pid(pid)
    --get a process by its PID(not of deepcopy, but the original process) with permission
    if permission.grantAccess(fs.perms.SYS)
     or processes[running].file == '/bin/cshell'
     or processes[running].file == '/sbin/login'
     or processes[running].file == '/sbin/kill'
     or processes[running].file == 'sbin/kill' then
        return processes[pid]
    else
        ferror("get_by_pid: perm error")
    end
end

--get itself as a process object
function get_itself()
    if permission.grantAccess(fs.perms.SYS)
     or processes[running].file == '/bin/cshell'
     or processes[running].file == '/sbin/login'
     or processes[running].file == '/sbin/kill'
     or processes[running].file == 'sbin/kill' then
        return processes[running]
    else
        ferror("get_itself: perm error")
    end
end

--same from original proc_manager

FLAG_CTTY = 0 --all processes in the same tty(the tty)
FLAG_ATTY = 1 --all process in all tty
FLAG_APRC = 2 --all process in the system

function filter_proc(filter_flag)
    if filter_flag == FLAG_CTTY then
        local ctty = os.lib.tty.getcurrentTTY()
        local filtered = {}
        for k,v in pairs(get_processes()) do
            if type(v) == 'table' then
                if v.tty == ctty.id then
                    filtered[v.pid] = v
                end
            end
        end
        return filtered
    elseif filter_flag == FLAG_ATTY or filter_flag == FLAG_APRC then
        local filtered = {}
        for k,v in pairs(get_processes()) do
            if type(v) == 'table' then
                filtered[v.pid] = v
            end
        end
        return filtered
    else
        ferror("proc.filter_proc: no flag")
        return nil
    end
end

function fork(f)
    local p = Process(f)
    set_parent(p, processes[running])
    return p
end
_G['fork'] = fork

function kill(pid, sig)
    local p = process[pid]
    if p.uid == os.lib.login.userUID() or os.lib.login.userUID() == 0 then
        killproc(processes[pid])
    end
end

function check_proof(p)
    -- check if a process is a original one(not a copy)
    if p == processes[p.pid] then
        return true
    end
    return false
end
libproc.check_proof = check_proof

function libroutine()
    _G['new_process'] = Process
    _G['libproc'] = libproc
end
