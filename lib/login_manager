#!/usr/bin/env lua
--login manager
--task: automate login, reading from /etc/shadow
--/bin/login uses login_manager
--/bin/whoami uses /tmp/current_user (from /bin/login), not login_manager

RELOADABLE = false

function strsplit(inputstr, sep)
        if sep == nil then
                sep = "%s"
        end
        local t={} ; i=1
        for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
                t[i] = str
                i = i + 1
        end
        return t
end

__CU = {}
__CU.username = ''
__CU.uid = -1

local __CVV = ''

Token = {}
Token.__index = Token
function Token.new()
    inst = {}
    setmetatable(inst, Token)
    inst.value = ''
    return inst
end

function Token:generate(u, sessions)
    self.value = u .. '::::' .. os.lib.hash.hash.sha256(os.generateSalt(100)) .. '::::' .. tostring(sessions)
end

function Token:verifyValid()
    local K = os.strsplit(self.value, "::::")
    if #K == 3 and tonumber(K[3]) ~= nil then
        if tonumber(K[3]) > 0 and K[2] == __CVV then
            return true
        else
            return false
        end
    end
    return false
end

--compare variable of __CVV on __CT.value
--if true, __CT is all valid
--if not, does not login pls

function Token:use()
    local K = os.strsplit(self.value, "::::")
    local nsession = tostring(tonumber(K[3]-1))
    os.debug.debug_write("[token] used token, now it has "..nsession.." uses", false)
    local new_2 = os.lib.hash.hash.sha256(os.generateSalt(100))
    __CVV = new_2
    local K2 = table.concat({K[1], new_2, nsession}, "::::")
    __CT.value = K2
end

function Token:getUser()
    local K = os.strsplit(self.value, "::::")
    return K[1]
end

function getCurrentToken()
    return __CT
end

__CT = Token.new()

function currentUser()
    return os.deepcopy(__CU)
end

local __sudo = false

function login(usr, pwd, isSudo)
    --TODO: session tokens
    if isSudo == nil then isSudo = false end
    if __CT:verifyValid() and __CT:getUser() == usr then
        __sudo = isSudo
        __CT:use()
        return true
    end
    local handler = fs.open('/etc/shadow', 'r')
    local lines = os.strsplit(handler.readAll(), '\n')
    handler.close()
    for k,v in ipairs(lines) do
        local udata = os.strsplit(v, '^')
        local hashed = os.lib.hash.hash.sha256(pwd .. udata[3])
        if udata[1] == usr and udata[2] == hashed then
            __CT:generate(udata[1], 3)
            __CVV = os.strsplit(__CT.value, '::::')[2]
            __CU.username = udata[1]
            if usr == 'root' then
                __sudo = isSudo
                os.debug.debug_write("[login] UID = 0", false)
                __CU.uid = 0
            else
                os.debug.debug_write("[login] UID = 1", false)
                __CU.uid = 1
            end
            return true
        end
    end
    return false
end

function isInGroup(uid, gid)
    return uid == gid
end

function front_login(program, user)
    local current_user = currentUser()
    if user == nil then user = current_user.username end
    write("["..program.."] password for "..user..": ")
    local try_pwd = read('')

    if login(current_user.username, try_pwd, true) then
        __CT:use()
        return true
    else
        os.ferror("front_login: Login incorrect")
        return false
    end
end

local counter = 6

function isSudo()
    if __sudo then
        if counter == 0 then
            __sudo = false
            return true
        else
            counter = counter - 1
            return true
        end
    end
    --print("nope, not __sudo")
    return false
end

function harmless_isSudo()
    return __sudo
end

function add_new_user(u, p)
    --adding new users to /etc/shadow
    --TODO: permissions
    local _salt = os.generateSalt(15)
    local hp = os.lib.hash.hash.sha256(p .. _salt)
    local user_string = u .. '^' .. hp .. '^' .. _salt ..  '\n'
    local h = fs.open("/etc/shadow", 'a')
    h.write(user_string)
    h.close()
    fs.makeDir("/home/"..u)
    return true
end

function changepwd(user, p, np)
    if login(user, p) then
        --change pwd
        local h = fs.open("/etc/shadow", 'r')
        local fLines = strsplit(h.readAll(), '\n')
        h.close()
        for k,v in pairs(fLines) do
            local pair = strsplit(v, '^')
            local _salt = os.generateSalt(15)
            if pair[1] == user then
                local _salt = os.generateSalt(15)
                pair[2] = os.lib.hash.hash.sha256(np .. _salt)
                fLines[k] = pair[1] .. '^' .. pair[2] .. '^' .. _salt .. '\n'
            else
                fLines[k] = fLines[k] .. '\n'
            end
        end
        local h2 = fs.open("/etc/shadow", 'w')
        for k,v in pairs(fLines) do
            h2.write(v)
        end
        h2.close()
        return true
    else
        return false
    end
end

--installing login API
function libroutine()
    os.login = {}
    os.login.login = login
    os.login.adduser = add_new_user
    os.login.changepwd = changepwd
end
