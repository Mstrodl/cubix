#!/usr/bin/env lua
--/bin/cshell: the cubix shell

local shellToken = {}
--local shell_wd = os.lib.control.get('/sbin/login', 'cwd')
local shell_wd = nil

--getting shell process
local itself = os.lib.proc.get_processes()[pget_running()]
local itself_pid = os.lib.proc.get_itself()

local shell_PS1 = '%u@%h:%w $'

if not os.cshell then
    os.cshell = {}
end
os.cshell.PATH = '/bin:/usr/bin:/usr/games'

local last_command = ''

function register_lcmd(c)
    os.lib.control.register_proof(itself_pid, 'last_cmd', c)
end

--TODO: a full language that integrates with the shell
function tokenize(data)
    local i = 0
    local tokens = {}
    while i < #data do
        local char = data[i]
        if char then
            tokens[#tokens + 1] = {['type']='paren', ['value']=char}
            i = i + 1
        end
    end
    return tokens
end

function parse(tokens)
end

function transform(ast)
end

function execute(ast)
end

--normal functions...
local function normal_command(cmd, context, _pipe)
    --normal routine to run commands
    local tokens = os.strsplit(cmd, ' ')
    local args = os.tail(tokens)
    if args == nil then args = {} end
    local program = tokens[1]
    --built-in "programs", handled by the shell
    if program == 'echo' then
        local message = os.strsplit(cmd, ';')[2]
        print(message)
        return 0
    elseif program == 'sleep' then
        if tokens[2] then
            os.sleep(tonumber(tokens[2]))
        else
            os.sleep(1)
        end
        return 0
    elseif program == 'APATH' then
    elseif program == 'PPATH' then
        print(os.cshell.PATH)
        return 0
    elseif program == 'getuid' then
        print(os.lib.login.userUID())
        return 0
    elseif program == 'getperm' then
        permission.getPerm()
        return 0
    elseif program == 'CTTY' then
        print(os.lib.tty.getcurrentTTY().id)
        return 0
    elseif program == 'source' then
        if tokens[2] ~= nil then
            run_script(tokens[2])
        end
        return 0
    elseif program == 'alias' then
        return 0
    end

    local found = false
    --part where we see paths and permissions to run and everything

    --check absolute paths
    if fs.exists(program) then
        --security check: check if program is in /sbin
        local tok = os.strsplit(program, '/')
        if tok[1] ~= '/sbin' then
            found = true
            os.runfile(program, args, itself, _pipe)
            register_lcmd(program .. ' ' .. table.concat(args, ' '))
        end
        --if its not, continue to other checks

    --check cwd .. program
    elseif not found and fs.exists(os.cshell.resolve(program)) then
        print(current_path)
        if shell_wd ~= '/sbin' or shell_wd ~= 'sbin' then
            found = true
            os.runfile(os.cshell.resolve(program), args, itself, _pipe)
            register_lcmd(os.cshell.resolve(program) .. ' ' .. table.concat(args, ' '))
        end
    end

    --check program in PATH
    local path = os.strsplit(os.cshell.PATH, ':')
    for _,token in ipairs(path) do
        local K = fs.combine(token..'/', program)
        if not found and fs.exists(K) then
            found = true
            os.runfile(K, args, itself, _pipe)
            register_lcmd(K .. ' ' .. table.concat(args, ' '))
        end
    end

    --check /sbin
    if not found and fs.exists(fs.combine("/sbin/", program)) then
        if os.lib.login.userUID() == 0 then
            found = true
            os.runfile(fs.combine("/sbin/", program), args, itself, _pipe)
            register_lcmd(fs.combine("/sbin/", program) .. ' ' .. table.concat(args, ' '))
        end
    end

    --not found
    if not found then
        ferror("csh: "..program..": program not found")
    end
end

local function shcmd(cmd)
    --parse command
    --nothing
    if cmd == nil or cmd == '' then return 0 end
    --comments
    if string.sub(cmd, 1, 1) == '#' then return 0 end
    --parse multiple commands
    for _, command in pairs(os.strsplit(cmd, "&&")) do
        if command:find("|") then --piping
            local count = 1
            local programs = os.strsplit(command, "|")
            local main_pipe = os.lib.pipe.Pipe.new('main')
            for _, prog in pairs(programs) do
                --[[
                For each program, run it with pipe support
                ]]
                normal_command(prog, nil, main_pipe)
            end
        else
            --if command does not have |, run program normally
            --now parse the command, with args and everything
            normal_command(command, nil)
        end
    end
end

os.cshell.resolve = function()
end

os.cshell.run = function(command)
    return shcmd(command)
end

os.cshell.cwd = function(newpwd)
    --only cd can use this
    local cdlock = os.lib.control.get('/bin/cd', 'cd_lock')
    if cdlock == '1' then
        shell_wd = newpwd
    else
        ferror("csh: cwd: cdlock ~= '1'")
    end
end

os.cshell.getwd = function()
    return shell_wd
end
os.cshell.getpwd = os.cshell.getwd
os.cshell.dir = os.cshell.getwd

os.cshell.resolve = function(pth)
    local wd = os.cshell.getwd()
    function _combine(c) return wd .. '/' .. c end
    function check_slash(s) return string.sub(s, 1, 1) == '/' end
    if check_slash(pth) then
        return pth
    else
        return _combine(pth)
    end
end

os.cshell.complete = function(pth)
end

os.cshell.exit = function()
end

function run_script(pth)
    local p = os.cshell.resolve(pth)
    k = fs.open(p, 'r')
    if k == nil then
        ferror("error opening file: "..p)
    end
    d = k.readAll()
    d = strsplit(d, "\n")
    for k,line in ipairs(d) do
        if string.sub(line,1,1) ~= '#' then
            normal_command(line)
        end
    end

    --[[
    tokens = tokenize(d)
    ast = parse(tokens)
    newAst = transform(ast)
    execute(newAst)
    ]]
end

function main(args)
    _G['os.shell'] = os.cshell
    _G['shell'] = os.cshell
    if #args == 0 then
        --get first cwd
        shell_wd = os.lib.control.get('/sbin/login', 'cwd')
        --generate a new token.
        shellToken = os.lib.login.Token.new(os.lib.login.currentUser(), 100)
        local HISTORY = {} --csh history
        local hostname = gethostname() --avoid multiple calls
        run_script('.cshrc')
        while true do --main loop
            if shellToken.user == 'root' then --always check if user is root
                shell_char = '#'
            else
                shell_char = '$'
            end
            write(shellToken.user)
            write("@"..hostname)
            write(":"..shell_wd)
            write(shell_char..' ')
            local cmd = read(nil, HISTORY, os.cshell.complete)
            if cmd == 'exit' then --hardcoded command
                return 0
            elseif cmd ~= nil then
                if command ~= '' or not command:find(" ") then
                    table.insert(HISTORY, cmd)
                end
                shcmd(cmd)
            end
        end
    else
        --run scripts
        run_script(os.cshell.resolve(args[1]))
    end
end

--running
main({...})
