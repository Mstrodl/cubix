#!/usr/bin/env lua
--/bin/wshell: cubix shell

_handler = {}
_handler.signal_handler = function (sig)
    if sig == 'kill' then
        print("cshell: recieved SIGKILL")
        return 0
    end
end

if os.loadAPI("/lib/debug_manager") then
    debug = _G["debug_manager"]
    debug.debug_write("debug: loaded", false)
else
    debug.debug_write = print
    debug.debug_write("debug: not loaded")
end

if os.loadAPI("/lib/tty_manager") then
    tty_mngr = _G["tty_manager"]
    os.debug.debug_write("[cshell] tty_manager: loaded", false)
else
    os.debug.debug_write("[cshell] tty_manager: not loaded")
end

if os.loadAPI("/lib/pipe_manager") then
    pipemngr = _G["pipe_manager"]
    os.debug.debug_write("[wshell] pipe_manager: loaded", false)
else
    os.debug.debug_write("[wshell] pipe_manager: not loaded")
end

function strsplit(inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        t[i] = str
        i = i + 1
    end
    return t
end

local cuser = fs.open("/tmp/current_user", 'r')
local cpath = fs.open("/tmp/current_path", 'r')
current_user = cuser.readAll()
current_path = cpath.readAll()
cuser.close()
cpath.close()

--term.clear()
--term.setCursorPos(1,1)

shell_tty = tty_mngr.new_tty("/dev/wshell_tty")
tty_mngr.using_tty("/dev/wshell_tty")

function shell_command(k)
    --TODO: add support for && (in cscript /etc/scripts/set_env.csp && ps && exit)
    --TODO: add support for &
    if k == nil or k == "" then return 0 end
    if k:find("|") then
        print("found pipe")
        local count = 1
        local programs = os.strsplit(k, "|")
        local npipe = pipemngr.new_empty_pipe('main')
        for k,v in pairs(programs) do
            local c = os.strsplit(v, ' ')
            local program = c[1]
            local pargs = {}
            for k,v in pairs(c) do
                if v ~= program then
                    pargs[#pargs+1] = tostring(v)
                end
            end
            if count > 2 then
                print("flushed")
                pipemngr.flush_pipe(npipe)
            end
            if fs.exists(program) then
                os.runfile_proc(program, pargs, nil, npipe)
            elseif fs.exists(fs.combine(current_path, program)) then
                os.runfile_proc(fs.combine(current_path, program), pargs, nil, npipe)
            elseif fs.exists(fs.combine("/bin/", program)) then
                os.runfile_proc(fs.combine("/bin/", program), pargs, nil, npipe)
            elseif fs.exists(fs.combine("/sbin/", program)) then
                if current_user == "root" then
                    os.runfile_proc(fs.combine("/sbin/", program), pargs, nil, npipe)
                else
                    os.ferror("you are not root to run this program!")
                end
            else
                os.ferror("Program not found")
            end
            count = count + 1
        end
    else
        local c = strsplit(k, " ")
        local program = c[1]
        if program == 'echo' then
            args = strsplit(k, ';')
            print(args[2])
            return 0
        end
        local args = {}
        for k,v in pairs(c) do
            if v == program then
            else
                args[#args+1] = v
            end
        end
        if fs.exists(program) then
            os.runfile_proc(program, args)
        elseif fs.exists(fs.combine(current_path, program)) then
            os.runfile_proc(fs.combine(current_path, program), args)
        elseif fs.exists(fs.combine("/bin/", program)) then
            os.runfile_proc(fs.combine("/bin/", program), args)
        elseif fs.exists(fs.combine("/sbin/", program)) then
            if current_user == "root" then
                os.runfile_proc(fs.combine("/sbin/", program), args)
            else
                os.ferror("you are not root to run this program!")
            end
        else
            os.ferror("Program not found")
        end
    end
end

os.cshell = {}
os.cshell.__shell_command = shell_command

function main(args)
    local command = ""
    local HISTORY = {}
    while true do
        local cuser = fs.open("/tmp/current_user", 'r')
        local cpath = fs.open("/tmp/current_path", 'r')
        current_user = cuser.readAll()
        current_path = cpath.readAll()
        cuser.close()
        cpath.close()
        if current_user == 'root' then
            shell_char = '# '
        else
            shell_char = '$ '
        end
        shell_tty.write(current_user .. ':' .. current_path .. shell_char)
        command = read(nil, HISTORY)
        table.insert(HISTORY, command)
        if command == "exit" then
            return 0
        elseif command ~= nil then
            shell_command(command)
        end
    end
    return 0
end

--os.sleep(3)
