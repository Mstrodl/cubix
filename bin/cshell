#!/usr/bin/env lua
--/bin/wshell: cubix shell

_handler = {}
_handler.signal_handler = function (sig)
    if sig == 'kill' then
        print("cshell: recieved SIGKILL")
        return 0
    end
end

if os.loadAPI("/lib/debug_manager") then
    debug = _G["debug_manager"]
    debug.debug_write("debug: loaded", false)
else
    debug.debug_write = print
    debug.debug_write("debug: not loaded")
end

if os.loadAPI("/lib/tty_manager") then
    tty_mngr = _G["tty_manager"]
    os.debug.debug_write("[cshell] tty_manager: loaded", false)
else
    os.debug.debug_write("[cshell] tty_manager: not loaded")
end

if os.loadAPI("/lib/pipe_manager") then
    pipemngr = _G["pipe_manager"]
    os.debug.debug_write("[wshell] pipe_manager: loaded", false)
else
    os.debug.debug_write("[wshell] pipe_manager: not loaded")
end

function strsplit(inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        t[i] = str
        i = i + 1
    end
    return t
end

local cuser = fs.open("/tmp/current_user", 'r')
local cpath = fs.open("/tmp/current_path", 'r')
current_user = cuser.readAll()
current_path = cpath.readAll()
cuser.close()
cpath.close()

--term.clear()
--term.setCursorPos(1,1)

shell_tty = tty_mngr.new_tty("/dev/wshell_tty")
tty_mngr.using_tty("/dev/wshell_tty")

os.cshell = {}
os.cshell.PATH = '/bin:/usr/bin'

function shell_command(k)
    --TODO: add support for && (in cscript /etc/scripts/set_env.csp && ps && exit)
    --TODO: add support for &
    if k == nil or k == "" then return 0 end
    if k:find("|") then
        local count = 1
        local programs = os.strsplit(k, "|")
        local npipe = pipemngr.Pipe.new('main')
        for k,v in pairs(programs) do
            local c = os.strsplit(v, ' ')
            local program = c[1]
            local pargs = {}
            for k,v in pairs(c) do
                if v ~= program then
                    pargs[#pargs+1] = tostring(v)
                end
            end

            local found = false
            if fs.exists(program) then
                found = true
                os.runfile_proc(program, pargs, nil, npipe)

            elseif fs.exists(fs.combine(current_path, program)) then
                found = true
                os.runfile_proc(fs.combine(current_path, program), pargs, nil, npipe)
            end
            
            _path = os.strsplit(os.cshell.PATH, ':')
            for k,v in ipairs(_path) do
                local K = fs.combine(v..'/', program)
                if fs.exists(K) then
                    found = true
                    os.runfile_proc(K, pargs, nil, npipe)
                end
            end
            
            if fs.exists(fs.combine("/sbin/", program)) then
                if current_user == "root" then
                    found = true
                    os.runfile_proc(fs.combine("/sbin/", program), pargs, nil, npipe)
                end
            end
            if not found then
                os.ferror("cshell: Program not found")
            end
        end
    else
        local c = strsplit(k, " ")
        local program = c[1]
        if program == 'echo' then
            args = strsplit(k, ';')
            print(args[2])
            return 0
        elseif program == 'APATH' then
            args = strsplit(k, ' ')
            os.cshell.PATH = os.cshell.PATH .. ':' .. args[2]
            return 0
        elseif program == 'PPATH' then
            print(os.cshell.PATH)
            return 0
        end
        local args = {}
        for k,v in pairs(c) do
            if v == program then
            else
                args[#args+1] = v
            end
        end
        local found = false
        if fs.exists(program) then
            found = true
            os.runfile_proc(program, args)

        elseif fs.exists(fs.combine(current_path, program)) then
            found = true
            os.runfile_proc(fs.combine(current_path, program), args)
        end

        _path = os.strsplit(os.cshell.PATH, ':')
        for k,v in ipairs(_path) do
            local K = fs.combine(v..'/', program)
            if fs.exists(K) then
                found = true
                os.runfile_proc(K, args)
            end
        end

        if fs.exists(fs.combine("/sbin/", program)) then
            if current_user == "root" then
                found = true
                os.runfile_proc(fs.combine("/sbin/", program), args)
            end
        end
        if not found then
            os.ferror("cshell: Program not found")
        end
    end
end


os.cshell.__shell_command = shell_command
os.cshell.complete = function()
    --return fs.complete(current_path)
end

function main(args)
    local command = ""
    local HISTORY = {}
    while true do
        local cuser = fs.open("/tmp/current_user", 'r')
        local cpath = fs.open("/tmp/current_path", 'r')
        current_user = cuser.readAll()
        current_path = cpath.readAll()
        cuser.close()
        cpath.close()
        if current_user == 'root' then
            shell_char = '# '
        else
            shell_char = '$ '
        end
        shell_tty.write(current_user .. ':' .. current_path .. shell_char)
        command = read(nil, HISTORY, os.cshell.complete)
        table.insert(HISTORY, command)
        if command == "exit" then
            return 0
        elseif command ~= nil then
            shell_command(command)
        end
    end
    return 0
end

--os.sleep(3)
