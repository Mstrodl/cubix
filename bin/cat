#!/usr/bin/env lua
--/bin/cat

_handler = {}
_handler.signal_handler = function(sig)
    if sig == 'kill' then
        --print("cat: SIGKILL")
        return 0
    end
end

if os.loadAPI("/lib/pipe_manager") then
    pipemngr = _G["pipe_manager"]
    os.debug.debug_write("[cat] pipe: loaded", false)
else
    os.debug.debug_write("[cat] pipe: not loaded")
end

function cat(file, bytes)
    local DEVICES = os.list_devices
    local MFILES = os.list_mfiles
    local cpth = fs.open("/tmp/current_path", 'r')
    local CURRENT_PATH = cpth.readAll()
    cpth.close()
    if DEVICES[file] ~= nil then
        print(DEVICES[file].read(bytes))
    elseif MFILES[file] ~= nil then
        print(MFILES[file].read(bytes))
    elseif fs.exists(file) and not fs.isDir(file) then
        local h = fs.open(file, 'r')
        print(h.readAll())
        h.close()
    elseif fs.exists(fs.combine(CURRENT_PATH, file)) and not fs.isDir(file) then
        local h = fs.open(fs.combine(CURRENT_PATH, file), 'r')
        print(h.readAll())
        h.close()
    elseif fs.exists(file) and fs.isDir(file) then
        print("cat: cannot cat into folders")
    else
        print("cat: file not found")
    end
end

function cat_pipe(pipe)
    local h = pipemngr.Pipe.copyPipe(pipe)
    while true do
        local line = h:readLine()
        if not line or line == nil then break end
        os.pprint(line, pipe, true)
    end
end

function main(args, pipe)
    if pipe == nil then
        cat(args[1], args[2])
    else
        cat_pipe(pipe)
    end
end

