#!/usr/bin/env lua
--/bin/yapi: Yet Another Package Installer (with a pacman syntax-like)

AUTHOR = 'Lukas Mendes'
VERSION = '0.1.3'

--defining some things
local SERVERIP = 'lkmnds.github.io'
local SERVERDIR = '/yapi'
local YAPIDIR = '/var/yapi'

function download_file(url)
    local cache = os.strsplit(url, '/')
    local fname = cache[#cache]
    print('request: ' .. fname)
    http.request(url)
    local req = true
    while req do
        local e, url, stext = os.pullEvent()
        if e == 'http_success' then
            local rText = stext.readAll()
            stext.close()
            return rText
        elseif e == 'http_failure' then
            req = false
            return {false, 'http_failure'}
        end
    end
end

function success(msg)
    term.set_term_color(colors.green)
    print(msg)
    term.set_term_color(colors.white)
end

function cache_file(data, filename)
    local h = fs.open(YAPIDIR..'/cache/'..filename, 'w')
    h.write(data)
    h.close()
    return 0
end

function isin(inputstr, wantstr)
    for i = 1, #inputstr do
        local v = string.sub(inputstr, i, i)
        if v == wantstr then return true end
    end
    return false
end

function create_default_struct()
    fs.makeDir(YAPIDIR.."/cache")
    fs.makeDir(YAPIDIR.."/db")
    fs.open(YAPIDIR..'/installedpkg', 'a').close()
end

function update_repos()
    --download core, community and extra
    local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/core'
    local k = download_file(SPATH)
    if type(k) == 'table' then
        ferror("yapi: http error")
        return 1
    end
    local _h = fs.open(YAPIDIR..'/db/core', 'w')
    _h.write(k)
    _h.close()
    local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/community'
    local k = download_file(SPATH)
    if type(k) == 'table' then
        ferror("yapi: http error")
        return 1
    end
    local _h = fs.open(YAPIDIR..'/db/community', 'w')
    _h.write(k)
    _h.close()
    local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/extra'
    local k = download_file(SPATH)
    if type(k) == 'table' then
        ferror("yapi: http error")
        return 1
    end
    local _h = fs.open(YAPIDIR..'/db/extra', 'w')
    _h.write(k)
    _h.close()
end

--Yapi Database
yapidb = {}
yapidb.__index = yapidb
function yapidb.new(path)
    local inst = {}
    setmetatable(inst, yapidb)
    inst.path = path
    inst.db = ''
    return inst
end

function yapidb:update()
    self.db = ''
    self.db = self.db .. '\n'
    local h = fs.open(self.path..'/core', 'r')
    local _k = h.readAll()
    self.db = self.db .. _k
    h.close()
    self.db = self.db .. '\n'
    local h = fs.open(self.path..'/community', 'r')
    local _k = h.readAll()
    self.db = self.db .. '\n'
    self.db = self.db .. _k
    h.close()
    self.db = self.db .. '\n'
    local h = fs.open(self.path..'/extra', 'r')
    local _k = h.readAll()
    self.db = self.db .. '\n'
    self.db = self.db .. _k
    self.db = self.db .. '\n'
    h.close()
end

function yapidb:search(pkgname)
    self:update()
    local _lines = self.db
    local lines = os.strsplit(_lines, '\n')
    for k,v in pairs(lines) do
        local pkgdata = os.strsplit(v, ';')
        if pkgdata[1] == pkgname then
            return {true, v}
        end
    end
    return {false, nil}
end

function yapidb:search_wcache(pkgname)
    self:update()
    if fs.exists(YAPIDIR..'/cache/'..pkgname..'.yap') then
        local h = fs.open(YAPIDIR..'/cache/'..pkgname..'.yap', 'r')
        local f = h.readAll()
        h.close()
        return f
    else
        local _url = self:search(pkgname)
        local url = os.strsplit(_url[2], ';')[2]
        local yapdata = download_file(url)
        if type(yapdata) == 'table' then return -1 end
        cache_file(yapdata, pkgname..'.yap')
        return yapdata
    end
end

--parsing yap files
function parse_yap(yapf)
    local lines = os.strsplit(yapf, '\n')
    local yapobject = {}
    yapobject['folders'] = {}
    yapobject['files'] = {}
    yapobject['deps'] = {}
    if type(lines) ~= 'table' then
        os.ferror("::! [parse_yap] type(lines) ~= table")
        return 1
    end
    local isFile = false
    local rFile = ''
    for _,v in pairs(lines) do
        if isFile then
            local d = v
            if d ~= 'EndFile;' then
                if yapobject['files'][rFile] == nil then
                    yapobject['files'][rFile] = d .. '\n'
                else
                    yapobject['files'][rFile] = yapobject['files'][rFile] .. d .. '\n'
                end
            else
                isFile = false
                rFile = ''
            end
        end
        local splitted = os.strsplit(v, ';')
        if splitted[1] == 'Name' then
            yapobject['name'] = splitted[2]
        elseif splitted[1] == 'Version' then
            yapobject['version'] = splitted[2]
        elseif splitted[1] == 'Build' then
            yapobject['build'] = splitted[2]
        elseif splitted[1] == 'Author' then
            yapobject['author'] = splitted[2]
        elseif splitted[1] == 'Email-Author' then
            yapobject['email_author'] = splitted[2]
        elseif splitted[1] == 'Description' then
            yapobject['description'] = splitted[2]
        elseif splitted[1] == 'Url' then
            yapobject['url'] = splitted[2]
        elseif splitted[1] == 'License' then
            yapobject['license'] = splitted[2]
        elseif splitted[1] == 'Folder' then
            table.insert(yapobject['folders'], splitted[2])
        elseif splitted[1] == 'File' then
            isFile = true
            rFile = splitted[2]
        elseif splitted[1] == 'Dep' then
            table.insert(yapobject['deps'], splitted[2])
        end
    end
    return yapobject
end

function yapidb:installed_pkgs()
    local handler = fs.open(YAPIDIR..'/installedpkg', 'r')
    local file = handler.readAll()
    handler.close()
    local lines = os.strsplit(file, '\n')
    return lines
end

function yapidb:is_installed(namepkg)
    local installed = self:installed_pkgs()
    for k,v in ipairs(installed) do
        local splitted = os.strsplit(v, ';')
        if splitted[1] == namepkg then return true end
    end
    return false
end

function yapidb:updatepkgs()
    self:update()
    for k,v in pairs(self:installed_pkgs()) do
        local pair = os.strsplit(v, ';')
        local w = self:search(pair[1])
        local yd = {}
        if w[1] == false then
            os.ferror("::! updatepkgs: search error")
            return false
        end
        local url = os.strsplit(w[2], ';')[2]
        local rawdata = download_file(url)
        if type(rawdata) == 'table' then
            os.ferror("::! [install] type(rawdata) == table : "..yapfile[2])
            return false
        end
        local yd = parse_yap(rawdata)
        if tonumber(pair[2]) < tonumber(yd['build']) then
            print(" -> new build of "..pair[1].." ["..pair[2].."->"..yd['build'].."] ")
            self:install(pair[1]) --install latest
        else
            print(" -> [updatepkgs] "..yd['name']..": OK")
        end
    end
end

function yapidb:register_pkg(yapdata)
    print("==> [register] "..yapdata['name'])
    local _h = fs.open(YAPIDIR..'/installedpkg', 'r')
    local _tLines = _h.readAll()
    _h.close()
    local pkg_found = false
    local tLines = os.strsplit(_tLines, '\n')
    for k,v in ipairs(tLines) do
        local pair = os.strsplit(v, ';')
        if pair[1] == yapdata['name'] then
            pkg_found = true
            tLines[k] = yapdata['name']..';'..yapdata['build']
        else
            tLines[k] = tLines[k] .. '\n'
        end
    end
    if not pkg_found then
        tLines[#tLines+1] = yapdata['name']..';'..yapdata['build'] .. '\n'
    end

    print(" -> writing to file")
    local h2 = fs.open(YAPIDIR..'/installedpkg', 'w')
    for k,v in pairs(tLines) do
        h2.write(v)
    end
    h2.close()
end

function yapidb:install_yap(yapdata)
    print("==> install_yap: "..yapdata['name'])
    for k,v in pairs(yapdata['folders']) do
        fs.makeDir(v)
    end
    for k,v in pairs(yapdata['files']) do
        local h = fs.open(k, 'w')
        h.write(v)
        h.close()
    end
    return true
end

function yapidb:return_dep_onepkg(pkgname)
    local _s = self:search(pkgname)
    if _s[1] == true then
        local result = os.strsplit(_s[2], ';')
        local yapfile = download_file(result[2])
        if type(yapfile) == 'table' then
            os.ferror("::! [getdep] "..yapfile[2])
            return false
        end
        cache_file(yapfile, pkgname..'.yap')
        local yapdata = parse_yap(yapfile)
        local dependencies = {}
        if yapdata['deps'] == nil then
            print(" -> no dependencies: "..pkgname)
            return {}
        end
        for _,dep in ipairs(yapdata['deps']) do
            if not self:is_installed(dep) then
                table.insert(dependencies, dep)
            end
        end
        return dependencies
    else
        return false
    end
end

function yapidb:return_deps(pkglist)
    local r = {}
    for _,pkg in ipairs(pkglist) do
        local c = self:return_dep_onepkg(pkg)
        if c == false then
            ferror("::! [getdeps] error getting deps: "..pkg)
            return nil
        end
        for i=0,#c do
            table.insert(r, c[i])
        end
        table.insert(r, pkg)
    end
    return r
end

function yapidb:install(pkgname)
    local _s = self:search(pkgname)
    if _s[1] == true then
        local result = os.strsplit(_s[2], ';')
        local yapfile = download_file(result[2])
        if type(yapfile) == 'table' then
            os.ferror("::! [install] "..yapfile[2])
            return false
        end
        cache_file(yapfile, pkgname..'.yap')
        local yapdata = parse_yap(yapfile)
        local missing_dep = {}
        if yapdata['deps'] == nil then
            print(" -> no dependencies: "..pkgname)
        else
            for _,dep in ipairs(yapdata['deps']) do
                if not self:is_installed(dep) then
                    table.insert(missing_dep, dep)
                end
            end
        end
        if #missing_dep > 0 then
            ferror("error: missing dependencies")
            for _,v in ipairs(missing_dep) do
                write(v..' ')
            end
            write('\n')
            return false
        end
        self:register_pkg(yapdata)
        self:install_yap(yapdata)
        return true
    else
        os.ferror("error: target not found: "..pkgname)
        return false
    end
end

function yapidb:remove(pkgname)
    --1st: read cached yapdata
    --2nd: remove all files made by yapdata['files']
    --3rd: remove entry in YAPIDIR..'/installedpkg'
    if not self:is_installed(pkgname) then
        os.ferror(" -> package not installed")
        return false
    end
    local yfile = self:search_wcache(pkgname)
    local ydata = parse_yap(yfile)
    --2nd part
    print("==> remove: "..ydata['name'])
    for k,v in pairs(ydata['files']) do
        --print(" -> removing "..k)
        fs.delete(k)
    end
    for k,v in pairs(ydata['folders']) do
        --print(" -> removing folder "..v)
        fs.delete(v)
    end
    --3rd part
    --print(" -> remove_entry: "..ydata['name'])
    local _h = fs.open(YAPIDIR..'/installedpkg', 'r')
    local _tLines = _h.readAll()
    _h.close()
    local pkg_found = false
    local tLines = os.strsplit(_tLines, '\n')
    for k,v in ipairs(tLines) do
        local pair = os.strsplit(v, ';')
        if pair[1] == ydata['name'] then
            tLines[k] = '\n'
        else
            tLines[k] = tLines[k] .. '\n'
        end
    end

    --print(" -> writing empty entry")
    local h2 = fs.open(YAPIDIR..'/installedpkg', 'w')
    for k,v in pairs(tLines) do
        h2.write(v)
    end
    h2.close()
    return true
end

function yapidb:clear_cache()
    fs.delete(YAPIDIR..'/cache')
    fs.makeDir(YAPIDIR..'/cache')
end

function main(args)
    if not permission.grantAccess(fs.perms.SYS) then
        os.ferror("yapi: not running as root")
        return 1
    end
    create_default_struct()
    if #args == 0 then
        print("usage: yapi <mode> ...")
    else
        local option = args[1]
        if string.sub(option, 1, 1) == '-' then
            if string.sub(option, 2,2) == 'S' then
                local packages = os.tail(args)
                if packages ~= nil then
                    local database = yapidb.new(YAPIDIR..'/db')
                    database:update()
                    for k,pkg in ipairs(packages) do
                        if not database:search(pkg)[1] then
                            os.ferror("error: target not found: "..pkg)
                            return 1
                        end
                    end
                    print("resolving dependencies...")
                    packages = database:return_deps(packages)
                    print("")
                    if packages == nil then
                        os.ferror("yapi: error getting deps")
                        return 1
                    end
                    write("Packages ("..#packages..") ")
                    for _,pkg in ipairs(packages) do
                        write(pkg..' ')
                    end
                    print("\n")
                    if not prompt(":: Proceed with installation?", "Y", "n") then
                        print("==> Aborted")
                        return true
                    end
                    for k,package in ipairs(packages) do
                        print(":: Installing packages ...")
                        local completed = 1
                        if database:install(package) then
                            success("("..completed.."/"..tostring(#packages)..")"..package.." : SUCCESS")
                            completed = completed + 1
                        else
                            return 1
                        end
                    end
                end

                if isin(option, 'c') then
                    local database = yapidb.new(YAPIDIR..'/db')
                    print("==> [clear_cache]")
                    database:clear_cache()
                end

                if isin(option, 'y') then
                    print(":: Update from "..SERVERIP)
                    if not http then
                        os.ferror("yapi: http not enabled")
                        return 1
                    end
                    update_repos()
                end

                if isin(option, 'u') then
                    local database = yapidb.new(YAPIDIR..'/db')
                    print(":: Starting full system upgrade")
                    if prompt("Confirm full system upgrade", "Y", "n") then
                        database:updatepkgs()
                    else
                        print("==> Aborted")
                    end
                end
            elseif string.sub(option,2,2) == 'U' then
                local yfile = os.cshell.resolve(args[2])
                print("==> [install_yap] "..yfile)
                if not fs.exists(yfile) then
                    ferror("-> file does not exist")
                    return 0
                end
                local h = fs.open(yfile, 'r')
                local _data = h.readAll()
                h.close()
                local ydata = parse_yap(_data)
                local database = yapidb.new(YAPIDIR..'/db')
                if database:install_yap(ydata) then
                    success("==> [install_yap] "..ydata['name'])
                else
                    os.ferror("::! [install_yap] "..ydata['name'])
                end
            elseif string.sub(option,2,2) == 'Q' then
                local database = yapidb.new(YAPIDIR..'/db')
                local pkg = args[2]
                local _k = database:search(pkg)
                if pkg then
                    if _k[1] == true then
                        local _c = database:search_wcache(pkg)
                        local yobj = parse_yap(_c)
                        if type(yobj) ~= 'table' then
                            os.ferror("::! [list -> parse_yap] error (yobj ~= table)")
                            return 1
                        end
                        print(yobj.name .. ' b' .. yobj.build .. ' v' .. yobj.version .. ' ('..yobj.license..')')
                        print("Maintainer: "..yobj.author.." <"..yobj['email_author']..">")
                        print("Description: "..yobj.description)
                        print("URL: "..yobj.url)
                    else
                        os.ferror("::! package not found")
                    end
                end
                if isin(option, 'e') then
                    local database = yapidb.new(YAPIDIR..'/db')
                    database:update()
                    local ipkg = database:installed_pkgs()
                    for _,ntv in ipairs(ipkg) do
                        local v = os.strsplit(ntv, ';')
                        write(v[1] .. ':' .. v[2] .. '\n')
                    end
                end
            elseif string.sub(option,2,2) == 'R' then
                local packages = os.tail(args)
                if packages ~= nil then
                    local database = yapidb.new(YAPIDIR..'/db')
                    database:update()
                    for k,pkg in ipairs(packages) do
                        if not database:search(pkg)[1] then
                            os.ferror("error: target not found: "..pkg)
                            return 1
                        end
                    end
                    if not prompt("Proceed with remotion?", "Y", "n") then
                        print("==> Aborted")
                        return true
                    end
                    for k,package in ipairs(packages) do
                        --local database = yapidb.new(YAPIDIR..'/db')
                        --database:update()
                        print(":: removing "..package)
                        if database:remove(package) then
                            success("==> [remove] "..package.." : SUCCESS")
                        else
                            os.ferror("::! [remove] "..package.." : FAILURE")
                            return 1
                        end
                    end
                end
            end
        else
            os.ferror("yapi: sorry, see \"man yapi\" for details")
        end
    end
end

main({...})
