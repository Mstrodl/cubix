#!/usr/bin/env lua
--/bin/yapi: Yet Another Package Installer (wieh a pacman syntax-like)

AUTHOR = 'Lukas Mendes'
VERSION = '0.1.0'

_handler = {}
_handler.signal_handler = function (sig)
    if sig == 'kill' then
        os.debug.debug_write("yapi: SIGKILL'd!", false)
        return 0
    end
end

--defining some things
local SERVERIP = 'lkmnds.github.io'
local SERVERDIR = '/yapi'
local YAPIDIR = '/var/yapi'

function download_file(url)
    http.request(url)
    local req = true
    while req do
        local e, url, stext = os.pullEvent()
        if e == 'http_success' then
            local rText = stext.readAll()
            stext.close()
            return rText
        elseif e == 'http_failure' then
            req = false
            return {false, 'http_failure'}
        end
    end
end

function success(msg)
    term.set_term_color(colors.green)
    print(msg)
    term.set_term_color(colors.white)
end

function cache_file(data, filename)
    local h = fs.open(YAPIDIR..'/cache/'..filename, 'w')
    h.write(data)
    h.close()
    return 0
end

function isin(inputstr, wantstr)
    for i = 1, #inputstr do
        local v = string.sub(inputstr, i, i)
        if v == wantstr then return true end
    end
    return false
end

function create_default_struct()
    fs.makeDir(YAPIDIR.."/cache")
    fs.open(YAPIDIR..'/db', 'a').close()
    fs.open(YAPIDIR..'/installedpkg', 'a').close()
end

--Yapi Database
yapidb = {}
yapidb.__index = yapidb
function yapidb.new(path)
    local inst = {}
    setmetatable(inst, yapidb)
    inst.path = path
    inst.db = ''
    return inst
end

function yapidb:update()
    local h = fs.open(self.path, 'r')
    local _k = h.readAll()
    self.db = _k
    h.close()
end

function yapidb:search(pkgname)
    self:update()
    local _lines = self.db
    local lines = os.strsplit(_lines, '\n')
    for k,v in pairs(lines) do
        local pkgdata = os.strsplit(v, ';')
        if pkgdata[1] == pkgname then
            return {true, v}
        end
    end
    return {false, nil}
end

function yapidb:search_wcache(pkgname)
    self:update()
    if fs.exists(YAPIDIR..'/cache/'..pkgname..'.yap') then
        local h = fs.open(YAPIDIR..'/cache/'..pkgname..'.yap', 'r')
        local f = h.readAll()
        h.close()
        return f
    else
        local _url = self:search(pkgname)
        local url = os.strsplit(_url[2], ';')[2]
        local yapdata = download_file(url)
        if type(yapdata) == 'table' then return -1 end
        cache_file(yapdata, pkgname..'.yap')
        return yapdata
    end
end

--parsing yap files
function parse_yap(yapf)
    local lines = os.strsplit(yapf, '\n')
    local yapobject = {}
    yapobject['folders'] = {}
    yapobject['files'] = {}
    if type(lines) ~= 'table' then
        os.ferror("[!] [parse_yap] type(lines) ~= table")
        return 1
    end
    local isFile = false
    local rFile = ''
    for _,v in pairs(lines) do
        if isFile then
            local d = v
            if d ~= 'EndFile;' then
                if yapobject['files'][rFile] == nil then
                    yapobject['files'][rFile] = d .. '\n'
                else
                    yapobject['files'][rFile] = yapobject['files'][rFile] .. d .. '\n'
                end
            else
                isFile = false
                rFile = ''
            end
        end
        local splitted = os.strsplit(v, ';')
        if splitted[1] == 'Name' then
            yapobject['name'] = splitted[2]
        elseif splitted[1] == 'Version' then
            yapobject['version'] = splitted[2]
        elseif splitted[1] == 'Build' then
            yapobject['build'] = splitted[2]
        elseif splitted[1] == 'Author' then
            yapobject['author'] = splitted[2]
        elseif splitted[1] == 'Email-Author' then
            yapobject['email_author'] = splitted[2]
        elseif splitted[1] == 'Description' then
            yapobject['description'] = splitted[2]
        elseif splitted[1] == 'Folder' then
            table.insert(yapobject['folders'], splitted[2])
        elseif splitted[1] == 'File' then
            isFile = true
            rFile = splitted[2]
        end
    end
    return yapobject
end

function yapidb:installed_pkgs()
    local handler = fs.open(YAPIDIR..'/installedpkg', 'r')
    local file = handler.readAll()
    handler.close()
    local lines = os.strsplit(file, '\n')
    return lines
end

function yapidb:is_installed(namepkg)
    local installed = self:installed_pkgs()
    for k,v in ipairs(installed) do
        local splitted = os.strsplit(v, ';')
        if splitted[1] == namepkg then return true end
    end
    return false
end

function yapidb:updatepkgs()
    self:update()
    for k,v in pairs(self:installed_pkgs()) do
        local pair = os.strsplit(v, ';')
        local w = self:search(pair[1])
        local yd = {}
        if w[1] == false then
            os.ferror("[!] [updatepkgs] search error")
            return false
        end
        local url = os.strsplit(w[2], ';')[2]
        local rawdata = download_file(url)
        if type(rawdata) == 'table' then
            os.ferror("[!] [install] type(rawdata) == table : "..yapfile[2])
            return false
        end
        local yd = parse_yap(rawdata)
        if tonumber(pair[2]) < tonumber(yd['build']) then
            print(" -> new build of "..pair[1].." ["..pair[2].."->"..yd['build'].."] ")
            self:install(pair[1]) --install latest
        else
            print(" -> [updatepkgs] "..yd['name']..": OK")
        end
    end
end

function yapidb:register_pkg(yapdata)
    print("==> [register_pkg] "..yapdata['name'])
    local _h = fs.open(YAPIDIR..'/installedpkg', 'r')
    local _tLines = _h.readAll()
    _h.close()
    local pkg_found = false
    local tLines = os.strsplit(_tLines, '\n')
    for k,v in ipairs(tLines) do
        local pair = os.strsplit(v, ';')
        if pair[1] == yapdata['name'] then
            pkg_found = true
            tLines[k] = yapdata['name']..';'..yapdata['build']
        else
            tLines[k] = tLines[k] .. '\n'
        end
    end
    if not pkg_found then
        tLines[#tLines+1] = yapdata['name']..';'..yapdata['build'] .. '\n'
    end

    print(" -> writing to file")
    local h2 = fs.open(YAPIDIR..'/installedpkg', 'w')
    for k,v in pairs(tLines) do
        h2.write(v)
    end
    h2.close()
end

function yapidb:install_yap(yapdata)
    print("==> [install_yap] "..yapdata['name'])
    for k,v in pairs(yapdata['folders']) do
        print(" -> folder:"..v)
        fs.makeDir(v)
    end
    for k,v in pairs(yapdata['files']) do
        print(" -> file:"..k)
        local h = fs.open(k, 'w')
        h.write(v)
        h.close()
    end
    return true
end

function yapidb:install(pkgname)
    print(" -> searching...")
    local _s = self:search(pkgname)
    if _s[1] == true then
        local result = os.strsplit(_s[2], ';')
        if not prompt("Do you want to install "..pkgname.."?", "Y", "n") then
            os.ferror("==> [install] aborted")
            return false
        end
        print(" -> getting YAP file... ("..result[2]..")")
        local yapfile = download_file(result[2])
        if type(yapfile) == 'table' then
            os.ferror("==> [install] "..yapfile[2])
            return false
        end
        cache_file(yapfile, pkgname..'.yap')
        local yapdata = parse_yap(yapfile)
        self:register_pkg(yapdata)
        self:install_yap(yapdata)
        return true
    else
        os.ferror("==> [install] yapidb: package not found")
        return false
    end
end

function yapidb:remove(pkgname)
    --1st: read cached yapdata
    --2nd: remove all files made by yapdata['files']
    --3rd: remove entry in YAPIDIR..'/installedpkg'
    if not self:is_installed(pkgname) then
        os.ferror(" -> package not installed")
        return false
    end
    local yfile = self:search_wcache(pkgname)
    local ydata = parse_yap(yfile)
    --2nd part
    print(" ==> [remove] "..ydata['name'])
    for k,v in pairs(ydata['files']) do
        print(" -> removing "..k)
        fs.delete(k)
    end
    for k,v in pairs(ydata['folders']) do
        print(" -> removing folder "..v)
        fs.delete(v)
    end
    --3rd part
    print("==> [remove_entry] "..ydata['name'])
    local _h = fs.open(YAPIDIR..'/installedpkg', 'r')
    local _tLines = _h.readAll()
    _h.close()
    local pkg_found = false
    local tLines = os.strsplit(_tLines, '\n')
    for k,v in ipairs(tLines) do
        local pair = os.strsplit(v, ';')
        if pair[1] == ydata['name'] then
            tLines[k] = '\n'
        else
            tLines[k] = tLines[k] .. '\n'
        end
    end

    print(" -> writing empty entry in installedpkg")
    local h2 = fs.open(YAPIDIR..'/installedpkg', 'w')
    for k,v in pairs(tLines) do
        h2.write(v)
    end
    h2.close()
    return true
end

function yapidb:clear_cache()
    fs.delete(YAPIDIR..'/cache')
    fs.makeDir(YAPIDIR..'/cache')
end

function main(args)
    if not permission.grantAccess(fs.perms.SYS) then
        os.ferror("yapi: not running as root")
        return 1
    end
    create_default_struct()
    if #args == 0 then
        print("usage: yapi <mode> ...")
    else
        print("yapi "..VERSION)
        local option = args[1]
        if string.sub(option, 1, 1) == '-' then
            if string.sub(option, 2,2) == 'S' then
                local packages = os.tail(args)
                if packages ~= nil then
                    for k,package in ipairs(packages) do
                        local database = yapidb.new(YAPIDIR..'/db')
                        database:update()
                        print("==> [install] "..package)
                        if database:install(package) then
                            success("==> [install] "..package.." : SUCCESS")
                        else
                            os.ferror("==> [install] "..package.." : FAILURE")
                            return 1
                        end
                    end
                end

                if isin(option, 'c') then
                    local database = yapidb.new(YAPIDIR..'/db')
                    print("==> [clear_cache]")
                    database:clear_cache()
                end

                if isin(option, 'y') then
                    print("==> [update_db] "..SERVERIP)
                    local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database'
                    if not http then
                        os.ferror("yapi: http not enabled")
                        return 1
                    end
                    local k = download_file(SPATH)
                    if type(k) == 'table' then
                        ferror("yapi: http error")
                        return 1
                    end
                    local _h = fs.open(YAPIDIR..'/db', 'w')
                    _h.write(k)
                    _h.close()
                    success("==> [update_db] SUCCESS")
                end

                if isin(option, 'u') then
                    local database = yapidb.new(YAPIDIR..'/db')
                    print("==> [updatepkgs] updating packages")
                    if prompt("Do you want to do a full system upgrade?", "Y", "n") then
                        database:updatepkgs()
                    end
                end
            elseif string.sub(option,2,2) == 'U' then
                local yfile = os.cshell.resolve(args[2])
                print("==> [install_yap] "..yfile)
                local h = fs.open(yfile, 'r')
                local _data = h.readAll()
                h.close()
                local ydata = parse_yap(_data)
                local database = yapidb.new(YAPIDIR..'/db')
                if database:install_yap(ydata) then
                    success("==> [install_yap] "..ydata['name'])
                else
                    os.ferror("[!] [install_yap] "..ydata['name'])
                end
            elseif string.sub(option,2,2) == 'Q' then
                local database = yapidb.new(YAPIDIR..'/db')
                local pkg = args[2]
                local _k = database:search(pkg)
                if pkg then
                    if _k[1] == true then
                        local _c = database:search_wcache(pkg)
                        local yobj = parse_yap(_c)
                        if type(yobj) ~= 'table' then
                            os.ferror("[!] [list -> parse_yap] error (yobj ~= table)")
                            return 1
                        end
                        print("Name: "..yobj.name)
                        print("Version: "..yobj.version..' (build:'..yobj.build..')')
                        print("Author: "..yobj.author.." <"..yobj['email_author']..">")
                        print("Description: "..yobj.description)
                    else
                        os.ferror("[!] [search] package not found")
                    end
                end
                if isin(option, 'e') then
                    local database = yapidb.new(YAPIDIR..'/db')
                    database:update()
                    print("Installed packages: ")
                    local ipkg = database:installed_pkgs()
                    for _,ntv in ipairs(ipkg) do
                        local v = os.strsplit(ntv, ';')
                        write(v[1] .. ' build ' .. v[2] .. '\n')
                    end
                end
            elseif string.sub(option,2,2) == 'R' then
                local packages = os.tail(args)
                if packages ~= nil then
                    if not prompt("Do you want to remove the selected packages?", "Y", "n") then
                        os.ferror("[remove] aborted")
                        return 0
                    end
                    for k,package in ipairs(packages) do
                        local database = yapidb.new(YAPIDIR..'/db')
                        database:update()
                        print("==> [remove] "..package)
                        if database:remove(package) then
                            success("==> [remove] "..package.." : SUCCESS")
                        else
                            os.ferror("==> [remove] "..package.." : FAILURE")
                            return 1
                        end
                    end
                end
            end
        else
            os.ferror("yapi: sorry, see \"man yapi\" for details")
        end
    end
end
