#!/usr/bin/env lua
--/bin/yapi: Yet Another Package Installer (with a pacman syntax-like)

--[[

This file serves as a refactor of YAPI, so I can compare them later.

Features included:
    * new YAP format(older YAP files will not be valid by now)
    * automatic checking on every install procedure
    * refactor of most code in 0.1.4

]]

--basic data
AUTHOR = 'Lukas Mendes'
VERSION = '0.2.0'

--default variables
local SERVERIP = 'lkmnds.github.io'
local SERVERDIR = '/yapi'

--default yapi directory
local YAPIDIR = '/var/yapi'

local YAPIDIR_CACHE = fs.combine(YAPIDIR, '/cache')
local YAPIDIR_DB = fs.combine(YAPIDIR, '/db')

--independent functions that do not depend on yapi stuff

function print_color(msg, c)
    term.set_term_color(c)
    print(msg)
    term.set_term_color(colors.white)
end

--success message
function success_msg(msg)
    print_color(msg, colors.green)
end

function warning(msg)
    print_color('[!] '..msg, colors.yellow)
end

--check if a letter is in a string
function isin(inputstr, wantstr)
    for i = 1, #inputstr do
        local v = string.sub(inputstr, i, i)
        if v == wantstr then return true end
    end
    return false
end

function inlist(str, list)
    for k,v in pairs(list) do
        if v == str then
            return true
        end
    end
    return false
end

function checkisin(list, list_old)
    for k,v in pairs(list_old) do
        for _,el in pairs(list) do
            if el == v then
                return v
            end
        end
    end
    return false
end

function abort(issuer)
    ferror("[abort] "..issuer)
    return false
end

--downloads files
function download_file(url)
    local cache = os.strsplit(url, '/')
    local fname = cache[#cache]
    print('request: ' .. fname)
    http.request(url)
    local req = true
    while req do
        local e, url, stext = os.pullEvent()
        if e == 'http_success' then
            local rText = stext.readAll()
            stext.close()
            return rText
        elseif e == 'http_failure' then
            req = false
            return {false, 'http_failure'}
        end
    end
end

function cache_file(fname, fdata)
    local h = fs.open(fs.combine(YAPIDIR_CACHE, fname), 'w')
    h.write(fdata)
    h.close()
end

function get_fcache(fname)
    local h = fs.open(fs.combine(YAPIDIR_CACHE, fname), 'r')
    if h == nil then return nil end
    local k = h.readAll()
    h.close()
    return k
end

function create_structure()
    fs.makeDir(YAPIDIR_CACHE)
    fs.makeDir(YAPIDIR_DB)
    fs.open(fs.combine(YAPIDIR, 'local'), 'a').close()
end

function update_repo(repo)
    local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/'..repo
    local k = download_file(SPATH)
    if type(k) == 'table' then
        return abort("http_repo:"..repo)
    end
    local _h = fs.open(YAPIDIR_DB..'/'..repo, 'w')
    _h.write(k)
    _h.close()
end

function update_repos()
    --download core, community and extra
    update_repo("core")
    update_repo("extra")
    update_repo("community")
end

function get_db(repo)
    local _h = fs.open(YAPIDIR_DB..'/'..repo, 'r')
    if _h == nil then
        ferror("error opening repo: "..repo)
        return nil
    end
    local k = _h.readAll()
    _h.close()
    return k
end

--YAP FORMAT HANDLING
function yap_parse(data)
    local yapdata = {}
    local lines = strsplit(data, '\n')

    yapdata['dep'] = {}
    yapdata['optdep'] = {}
    yapdata['files'] = {}
    yapdata['folders'] = {}

    local isFile = false
    local rFile = ''
    for _,line in ipairs(lines) do
        if isFile then
            if line ~= 'END_FILE;' then
                if yapdata['files'][rFile] == nil then
                    yapdata['files'][rFile] = d .. '\n'
                else
                    yapdata['files'][rFile] = yapobject['files'][rFile] .. d .. '\n'
                end
            else
                isFile = false
                rFile = ''
            end
        else
            local p = strsplit(line, '=')
            local f = strsplit(line, ';')
            if p[1] == 'name' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'build' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'version' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'desc' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'author' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'email-author' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'contri' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'url' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'packager' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'arch' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'license' then
                yapdata[p[1]] = p[2]
            elseif p[1] == 'depend' then
                table.insert(yapdata['dep'], p[2])
            elseif p[1] == 'optdepend' then
                table.insert(yapdata['optdep'], p[2])
            elseif f[1] == 'file' then
                isFile = true
                rFile = f[2]
            elseif f[1] == 'folder' then
                table.insert(yapdata['folders'], f[2])
            end
        end
    end
    return yapdata
end

function yap_list_files(yapdata)
    local extracted = {}
    for k,v in pairs(yapdata['files']) do
        table.insert(extracted, k)
    end
    return extracted
end

function yap_install(yapdata)
    os.viewTable(yapdata)
    for k,v in pairs(yapdata['files']) do
        table.insert(extracted, k)
    end
end
--END YAP FORMAT HANDLING

--DATABASE CLASS
Yapidb = class(function(self)
    self.path_folder = YAPIDIR_DB
    self.db_core = {}
    self.db_extra = {}
    self.db_community = {}
    self:update_files()
end)

function Yapidb:update_r(repo, dbdata)
    local lines = strsplit(dbdata, '\n')
    local currentpkg = ''
    for _,line in ipairs(lines) do
        --parse line
        local spaces = strsplit(line, ' ')
        local equal = strsplit(line, '=')
        if string.sub(line, 1, 1) == 'p' then --package entry
            local tok = strsplit(line, ':')
            local pkgname = strsplit(tok[1], ' ')[2]
            local pkgdeps = strsplit(tok[2], ',')

            --remove {
            local n = #pkgdeps
            pkgdeps[n] = string.sub(pkgdeps[n], 0, #pkgdeps[n] - 1)

            self['db_'..repo][pkgname] = {
                pkgdeps=pkgdeps
            }
            currentpkg = pkgname
        elseif spaces[1] == 'build' then
            local pkgbuild = spaces[2]
            self['db_'..repo][currentpkg]['build'] = pkgbuild
        elseif equal[1] == 'yapfile' then
            local url = equal[2]
            if url == 'default' then
                yapurl = 'http://' .. SERVERIP .. SERVERDIR .. '/core/' .. currentpkg .. '.yap'
            else
                yapurl = url
            end
            self['db_'..repo][currentpkg]['url'] = yapurl
        elseif line == '}' then
            currentpkg = ''
        end
    end
end

function Yapidb:update_files()
    --[[
    Format in code:
    self.db_core[pkgname] = {deps={d1, d2, d3, ...}, build=Number, yapfile='default' OR "http://..."}
    ]]
    self:update_r('core', get_db("core"))
    self:update_r('extra', get_db("extra"))
    self:update_r('community', get_db("community"))
end

function Yapidb:search(repo, pkgname)
    if self['db_'..repo][pkgname] ~= nil then
        return true
    end
end

function Yapidb:find(pkg)
    local pkg_core = self:search('core', pkg)
    local pkg_extra = self:search('extra', pkg)
    local pkg_community = self:search('community', pkg)
    if pkg_core then
        return 'core'
    elseif pkg_extra then
        return 'extra'
    elseif pkg_community then
        return 'community'
    else
        return false
    end
end

function Yapidb:getd(repo, pkg)
    return self['db_'..repo][pkg]
end

function Yapidb:check_dep(yapdata)
    local missing_dep = {}
    if yapdata['deps'] == nil then
        return nil
    else
        for _,dep in ipairs(yapdata['deps']) do
            if not self:is_installed(dep) then
                table.insert(missing_dep, dep)
            end
        end
    end
    return missing_deps
end

--install function, takes a package name and installs it.
function Yapidb:install(pkg)
    local pkg_repo = self:find(pkg)
    local pkgd = self:getd(pkg_repo, pkg)

    --download and cache the yap file
    self:job_status("downloading "..pkg)
    local pkgyap = download_file(pkgd['url'])
    cache_file(pkg..'.yap', pkgyap)

    --check conflict files
    self:job_status("checking "..pkg)
    self:check_conflicts({pkg})

    --parse yap and install it
    self:job_status("parsing "..pkg)
    local ydata = yap_parse(pkgyap)
    if ydata == nil then
        ferror("install: error in yap parsing")
        return false
    end

    --check dependencies of a yap
    local mdep = self:check_dep(ydata)
    if mdep == nil then
        print("no deps: "..pkg)
    else
        ferror("install: missing dependencies for "..pkg.."can't continue")
        return false
    end

    --install
    self:job_status("installing "..pkg)
    if yap_install(ydata) then
        self:register_pkg(ydata)
        return true
    else
        return false
    end
end

function Yapidb:remove(pkg)
end

function Yapidb:get_deps(pkglist)
    local new_pkglist = {}
    for _,pkg in ipairs(pkglist) do
        local pkg_repo = self:find(pkg)
        local pkgd = self:getd(pkg_repo, pkg)
        for _,dep in ipairs(pkgd['pkgdeps']) do
            if dep ~= '' then
                table.insert(new_pkglist, dep)
            end
        end
        table.insert(new_pkglist, pkg)
    end
    return new_pkglist
end

--job functions
function Yapidb:set_jobs(joblist)
    self.jobn = #joblist
    self.jobs = joblist
    self.curjob = 1
end

function Yapidb:job_status(st)
    print('('..self.curjob .. '/'..self.jobn..') '.. st)
end

function Yapidb:job_next()
    self.curjob = self.curjob + 1
end
--end job functions

function Yapidb:bscinfo(pkgd, pkgn)
    return pkgn .. ':' .. pkgd['build']
end

function Yapidb:get_installed_data()
    local instldata = {}
    --key = pkgname, v = {build=b}
    local f = fs.open(fs.combine(YAPIDIR, 'local'), 'r')
    local ld = f.readAll()
    f.close()
    for _,line in ipairs(strsplit(ld, '\n')) do
        --parse local file
    end
    return instldata
end

function Yapidb:get_all_installed()
    local idat = self:get_installed_data()
    local pkginstl = {}
    for pkg,dat in pairs(idat) do
        table.insert(pkginstl, self:bscinfo(dat, pkg))
    end
    return pkginstl
end

function Yapidb:is_installed(pkgname)
    --check all entries in local and see
end

function Yapidb:check_conflicts(pkgnew)
    if pkgnew == nil then
        --default way: check all installed packages
        local idata = self:get_installed_data()
        local pkgfiles = {}
        for pkg,pkgd in pairs(idata) do
            --treat every package as new
            self:check_conflicts({pkg})
        end
    else
        --check new packages(with cache, by default) and compare used files
        for _,pkg in ipairs(pkgnew) do
            local cached = get_fcache(pkg..'.yap')
            if cached == nil or cached == '' then
                ferror("conflict_check: cache not found: "..pkg)
                return false
            end
            local lfpkg = yap_list_files(yap_parse(cached))

            local idata = self:get_installed_data()
            local pkgfiles = {}
            for pkgn,pkgd in pairs(idata) do
                local c = get_fcache(pkgn..'.yap')
                local lf = yap_list_files(yap_parse(c))
                local k = checkisin(lfpkg, lf)
                if k then
                    ferror("File conflict between "..pkg.."(new) and "..pkgn.."(old)")
                    ferror("File is "..k)
                    ferror("Cannot continue with conflicts, aborting")
                    return abort("conflict_error")
                end
            end
        end
    end
end

function Yapidb:usual_check()
    self:check_conflicts()
end
--END DATABASE

function main(args)
    if not permission.grantAccess(fs.perms.SYS) then
        ferror("yapi must be run as root not uid "..tostring(os.lib.login.userUID()))
        return 1
    end
    create_structure()
    if #args == 0 then
        print("usage: yapi <mode> ...")
        return 0
    end

    local mode = args[1]
    local arguments = tail(args)
    if string.sub(mode, 1, 1) == '-' then
        if string.sub(mode, 2, 2) == 'S' then
            if arguments ~= nil then
                local ydb = Yapidb()
                ydb:usual_check()

                --check if all packages exist
                for _,pkg in ipairs(arguments) do
                    if ydb:find(pkg) == false then
                        return ferror("error: target not found: "..pkg)
                    end
                end

                --sanity check, installing already installed packages
                local alld = ydb:get_installed_data()
                for _,pkg in ipairs(arguments) do
                    if ydb:is_installed(pkg) then
                        warning(ydb:bscinfo(alld[pkg], pkg)..' already installed - reinstalling')
                    end
                end

                --get deps
                print("resolving dependencies...")
                local packages = ydb:get_deps(arguments)
                print("")
                if packages == nil then
                    return ferror("yapi: error getting dependencies")
                end

                --Cubix Standard rule 1 check
                if inlist('base', packages) then
                    ferror("WARNING: As Cubix Standards, devs should not install the base package as it will damage existing changes that they made.")
                    ferror("\nWARNING2: Only users with consent that all personal data will be lost after installation should continue.")
                    if prompt("Do you really want to go with this?", "Y", "n") then
                        if prompt("Do you REALLY want to go with this?", "Y", "n") then
                            print("Ok then... don't issue this at github, pls.")
                        end
                        return abort("base_warning")
                    else
                        return abort("base_warning")
                    end
                end

                --user consent
                write("Packages ("..#packages..") ")
                for _,pkg in ipairs(packages) do
                    write(pkg..' ')
                end
                print("\n")
                if not prompt(":: Proceed with install?", "Y", "n") then
                    return abort("install_prompt")
                end

                --installing.
                ydb:set_jobs(packages)
                for _, package in ipairs(packages) do
                    print(":: Installing ...")
                    if ydb:install(package) then
                        ydb:job_status("SUCCESS")
                        ydb:job_next()
                    else
                        return abort("install_error")
                    end
                end
            end

            if isin(mode, 'c') then
                Yapidb():clear_cache()
            end

            if isin(mode, 'y') then
                if not http then
                    return abort("http not enabled")
                end
                update_repos()
            end

            if isin(mode, 'u') then
                --full system upgrade
                local ydb = Yapidb()
                ydb:usual_check()
                print(":: Starting full system upgrade")
                if prompt("Confirm full system upgrade", "Y", "n") then
                    ydb:full_upgrade()
                else
                    return abort("update_full_upgrade")
                end
            end
        elseif string.sub(mode, 2, 2) == 'R' then
        elseif string.sub(mode, 2, 2) == 'Q' then
        elseif string.sub(mode, 2, 2) == 'U' then
        elseif string.sub(mode, 2, 2) == 'F' then
        end
    end
end

main({...})
