#!/usr/bin/env lua
--/sbin/cubix_live_installer: starts a enviroment where the user can install cubix

AUTHOR = "Lukas Mendes"
VERSION = "0.0.2"
BUILD_DATE = "2015-12-05"

--[[
    The Cubix Live Installer has the basic utilities to install cubix
    It has these Arch Linux vibe going on so, yeah

    CubixLI has everything in one script: a shell, a downloader to install cubix, setting label, hostname and so on
]]

--[[
    TODOs:
        -some kind of chroot
]]

function do_halt()
    while true do sleep(0) end
end

tail = function(t)
       if # t <= 1 then
          return nil
       end
       local newtable = {}
       for i, v in ipairs(t) do
          if i > 1 then
              table.insert(newtable, v)
          end
       end
       return newtable
end

strsplit = function (inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    if inputstr == nil then
        return ''
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        t[i] = str
        i = i + 1
    end
    return t
end

viewtable = function (t)
    print(t)
    for k,v in pairs(t) do
        print(k..","..tostring(v).." ("..type(v)..")")
    end
end

function _prompt(message, yes, nope)
    write(message..'['..yes..'/'..nope..'] ')
    local result = read()
    if result == yes then
        return true
    else
        return false
    end
end

term.set_term_color = function (c)
    if term.isColor() then
        term.setTextColor(c)
    end
end

function ferror(msg)
    term.set_term_color(colors.red)
    print(msg)
    term.set_term_color(colors.white)
end

function normal(msg)
    term.set_term_color(colors.yellow)
    print(msg)
    term.set_term_color(colors.white)
end

function load_env()
    normal("[cubixli:load_screen]")
    term.clear()
    term.setCursorPos(1,1)
    normal("[cubixli:load_disk]")
    print("[cubixli:main->run_shell]")
end

local current_path = '/'
local current_envir = ''

local current_disks = {
    hdd = {{"hdd1", "part", "/"}},
    cubixli_ramdisk = {{"loop", "loopspecial", "./loop"}, {"emudev", "edevfs", "./dev"}}
}

local override = false

function cubixli_delete_disk(args)
    local disk = args[1]
    if disk == 'hdd' or disk == 'hdd1' or disk == '/' then
        normal("[cubixli:delete_disk] wiping hdd")
        for k,v in pairs(fs.list('/'))do
            if v ~= 'rom' then
                fs.delete(v)
            end
        end
    elseif disk == 'cubixli_ramdisk' or disk == 'loop' or disk == 'emudev' then
        if not override then
            ferror("cubixli_delete_disk: sorry, you can't format "..disk)
            return 1
        else
            ferror("SAY WHAT??")
            ferror("[CRITICAL] cubixli can't do anything now(due to a monster or a wipeout on cubixli partitions, needs manual reboot now.)")
            do_halt()
        end
    else
        ferror("cubixli_delete_disk: pls say what disk")
        return 1
    end
    return 0
end

_G['cubixli_delete_disk'] = cubixli_delete_disk

function cubixli_call(func, args)
    if current_envir ~= 'cubixli' then
        ferror("cubixli_call: cubixli env not loaded")
        return false
    end
    normal("[cubix:"..func.."]")
    local result = _G['cubixli_'..func](args)
    if result == 0 then return true end
    return false
end

--deldisk binary
function deldisk(args)
    if #args == 0 then print("usage: deldisk <disk>") return 0 end
    if _prompt("Do you want to delete your disk?", "Y", "n") then
        if cubixli_call("delete_disk", args) then
            print("deldisk: deleted all files in /")
        else
            ferror("deldisk: error calling delete_disk")
        end
    else
        return 0
    end
end

--lsblk binary
function lsblk()
    for k,vl in pairs(current_disks) do
        write(k..':\n')
        for _, v in pairs(vl) do
            write("  "..v[1].." type "..v[2].." mounted in "..v[3]..'\n')
        end
    end
    write('\n')
    return 0
end

--yapstrap binary
function yapstrap(args)
    if current_envir ~= 'cubixli' then
        ferror("yapstap: cubixli env not loaded")
        return 1
    end
    if #args == 0 then print("usage: yapstrap <task>") return 0 end
    for k,v in pairs(args) do
        if v == 'cubix' then
            normal("yapstrap: task assigned: "..v)
            shell.run("pastebin run W5ZkVYSi lkmnds cubix")
            normal("yapstrap: finishing "..v.." task")
            shell.run("FINISHINSTALL")
            normal("yapstrap: finished "..v.." task")
        end
    end
    return 0
end

--ls binary
local chars = {}
for i = 32, 126 do chars[string.char(i)] = i end

local function sortingComparsion(valueA, valueB)
    local strpos = 0
    local difference = 0
    while strpos < #valueA and strpos < #valueB and difference == 0 do
        strpos = strpos + 1
        if chars[string.sub(valueA, strpos, strpos)] > chars[string.sub(valueB, strpos, strpos)] then
            difference = 1
        elseif chars[string.sub(valueA, strpos, strpos)] < chars[string.sub(valueB, strpos, strpos)] then
            difference = -1
        end
    end
    if difference == -1 then
        return true
    else
        return false
    end
end

function _ls(pth)
    local nodes = fs.list(pth)
    local files = {}
    local folders = {}
    for k,v in ipairs(nodes) do
        if fs.isDir(pth..'/'..v) then
            table.insert(folders, v)
        else
            table.insert(files, v)
        end
    end
    table.sort(folders, sortingComparsion)
    table.sort(files, sortingComparsion)
    --printing folders
    term.set_term_color(colors.green)
    for k,v in ipairs(folders) do
        write(v..' ')
    end
    term.set_term_color(colors.white)
    --printing files
    for k,v in ipairs(files) do
        write(v..' ')
    end
    write('\n')
end

function ls(args)
    local p = args[1]
    if p == nil then
        _ls(current_path)
    elseif fs.exists(p) then
        _ls(p)
    elseif fs.exists(fs.combine(current_path, p)) then
        _ls(fs.combine(current_path, p))
    end
end

--cd binary
function pth_goup(p)
    elements = strsplit(p, '/')
    res = ''
    for i = 1, (#elements - 1) do
        print(res)
        res = res .. '/' .. elements[i]
    end
    return res
end

function _cd(pth)
    local CURRENT_PATH = current_path
    if CURRENT_PATH == nil then
        CURRENT_PATH = '/'
    elseif pth == '.' then
        CURRENT_PATH = CURRENT_PATH
    elseif pth == '..' then
        CURRENT_PATH = pth_goup(CURRENT_PATH)
    elseif pth == '/' then
        CURRENT_PATH = pth
    elseif fs.exists(CURRENT_PATH .. '/' .. pth) == true then
        CURRENT_PATH = CURRENT_PATH .. '/' .. pth
    elseif fs.exists(pth) == true then
        CURRENT_PATH = pth
    elseif pth == nil then
        CURRENT_PATH = "/home/"..current_user
    else
        print("cd: not found!")
    end
    return CURRENT_PATH
end

function cd(args)
    local pth = args[1]
    local npwd = _cd(pth)
    current_path = npwd
end

--"cat"ing
function cat(args)
    if #args == 0 then print("usage: cat <absolute path>") return 0 end
    local file = args[1]
    if fs.exists(file) then
        local f = fs.open(file, 'r')
        local data = f.readAll()
        f.close()
        print(data)
        return 0
    else
        ferror("cat: file not found")
        return 1
    end
end

--interface for rebooting
function front_reboot(args)
    if current_envir == 'cubixli' then
        ferror("front_reboot: cannot reboot with cubixli enviroment loaded, please use unloadenv")
        return 1
    end
    print("[cubixli:front_reboot] sending RBT")
    os.sleep(1.5)
    os.reboot()
end

--interface for "shutdowning"
function front_shutdown(args)
    if current_envir == 'cubixli' then
        ferror("front_shutdown: cannot reboot with cubixli enviroment loaded, please use unloadenv")
        return 1
    end
    print("[cubixli:front_shutdown] sending HALT")
    os.sleep(1.5)
    os.shutdown()
end

--set label
function setlabel(args)
    if #args == 0 then print("usage: setlabel <newlabel>") return 0 end
    os.setComputerLabel(tostring(args[1]))
end

--version of cubixLI
function version()
    print("CubixLI "..VERSION.." in "..BUILD_DATE)
end

--load enviroment for cubix to start
function loadenviroment(args)
    if #args == 0 then return 0 end
    normal("[cubixli:loadenviroment] loading "..tostring(args[1]))
    current_envir = tostring(args[1])
end

--unload enviroment
function unloadenv()
    normal("[cubixli:unloadenv] unloading current enviroment ")
    local handler = fs.open("/tmp/install_lock", 'w')
    handler.close()
    current_envir = ''
end

--sethostname binary
function sethostname(args)
    if current_envir ~= 'cubixli' then
        ferror("sethostname: cubxli enviroment not loaded")
        return 1
    end
    local nhostname = tostring(args[1])
    normal("[cubixli:sethostname] setting hostname to "..nhostname)
    local hostname_handler = fs.open("/etc/hostname", 'w')
    hostname_handler.write(nhostname)
    hostname_handler.close()
    return 0
end

--install help
function insthelp()
    print([[
Installing cubix:
    loadenv cubixli
    lsblk
    deldisk hdd
    yapstrap cubix
    setlabel <your label here>
    sethostname <your hostname here>
    unloadenv
    reboot
]])
    return 0
end

function runpath(args)
    --PLEASE DONT USE THIS
    os.run({}, args[1], unpack(tail(args)))
end

function override_shell()
    write("command to run with override=true:")
    local cmd = read()
    override = true
    shellcmd(cmd)
    override = false
    return 0
end

local SHELLCMD = {}
SHELLCMD['ls'] = ls
SHELLCMD['cd'] = cd
SHELLCMD['yapstrap'] = yapstrap
SHELLCMD['deldisk'] = deldisk
SHELLCMD['setlabel'] = setlabel
SHELLCMD['loadenv'] = loadenviroment
SHELLCMD['unloadenv'] = unloadenv
SHELLCMD['version'] = version
SHELLCMD['help'] = insthelp
SHELLCMD['reboot'] = front_reboot
SHELLCMD['shutdown'] = front_shutdown
SHELLCMD['run'] = runpath
SHELLCMD['lsblk'] = lsblk
SHELLCMD['sethostname'] = sethostname
SHELLCMD['cat'] = cat
SHELLCMD['override'] = override_shell

function list_cmds(args)
    print("Available commands:")
    for k,v in pairs(SHELLCMD) do 
        write(k..' ')
    end
    write('\n')
end

SHELLCMD['cmds'] = list_cmds

function shellcmd(cmd)
    local k = strsplit(cmd, ' ')
    local _args = tail(k)
    if _args == nil then _args = {} end
    if SHELLCMD[k[1]] ~= nil then
        SHELLCMD[k[1]](_args)
    else
        ferror("clish: command not found")
    end
end

function run_shell()
    --THIS IS NOT CSHELL!!!!11!!!ELEVEN!!
    local command = ""
    local shell_char = '# '
    local current_user = 'root'
    local HISTORY = {}
    while true do
        write(current_user .. ':' .. current_path .. shell_char)
        command = read(nil, HISTORY)
        table.insert(HISTORY, command)
        if command == "exit" then
            return 0
        elseif command ~= nil then
            shellcmd(command)
        end
    end
    return 0
end

function main()
    if _G["IS_CUBIX"] then
        ferror("cubixli: in cubix, cubixli must run as root")
        return 0
    end
    load_env()
    run_shell()
end

main()

