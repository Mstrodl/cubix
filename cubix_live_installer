#!/usr/bin/env lua
--cubix_live_installer(cubixli): starts a enviroment where the user can install cubix

AUTHOR = "Lukas Mendes"
VERSION = "0.1.0"
BUILD_DATE = "2016-01-26"

--[[
    The Cubix Live Installer has the basic utilities to install cubix
    It has these Arch Linux vibe going on so, yeah

    CubixLI has everything in one script: a shell, a downloader to install cubix, setting label, hostname and so on

    pastebin: B1t3L4Uw
]]

function do_halt()
    while true do sleep(0) end
end

tail = function(t)
       if # t <= 1 then
          return nil
       end
       local newtable = {}
       for i, v in ipairs(t) do
          if i > 1 then
              table.insert(newtable, v)
          end
       end
       return newtable
end

strsplit = function (inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    if inputstr == nil then
        return ''
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        t[i] = str
        i = i + 1
    end
    return t
end

viewtable = function (t)
    print(t)
    for k,v in pairs(t) do
        print(k..","..tostring(v).." ("..type(v)..")")
    end
end

function _prompt(message, yes, nope)
    write(message..'['..yes..'/'..nope..'] ')
    local result = read()
    if result == yes then
        return true
    else
        return false
    end
end
prompt = _prompt

term.set_term_color = function (c)
    if term.isColor() then
        term.setTextColor(c)
    end
end

function ferror(msg)
    term.set_term_color(colors.red)
    print(msg)
    term.set_term_color(colors.white)
end

function normal(msg)
    term.set_term_color(colors.yellow)
    print(msg)
    term.set_term_color(colors.white)
end

function load_env()
    normal("[cubixli:load_screen]")
    term.clear()
    term.setCursorPos(1,1)
    normal("[cubixli:load_disk]")
    print("[cubixli:main->run_shell]")
end

local current_path = '/'
local current_envir = ''

local current_disks = {
    hdd = {
        {"hdd", "part", "/"}
    },

    cubixli_ramdisk = {
        {"edev", "edevfs", "./dev"},
        {"cbxli", "cbxlifs", "./cbxli"}
    }
}

local override = false

function cubixli_delete_disk(args)
    local disk = args[1]
    if disk == 'hdd' or disk == '/' then
        normal("[cubixli:delete_disk] wiping hdd")
        for k,v in pairs(fs.list('/'))do
            if v ~= 'rom' then
                fs.delete(v)
            end
        end
    elseif disk == 'cubixli_ramdisk' or disk == 'cbxli' or disk == 'emudev' then
        if not override then
            ferror("cubixli_delete_disk: perm_error formatting "..disk)
            return 1
        else
            ferror("[HALT_ERROR] cubixli needs a manual reboot. (ctrl+r btw)")
            do_halt()
        end
    else
        ferror("cubixli_delete_disk: error getting disk")
        return 1
    end
    return 0
end

_G['cubixli_delete_disk'] = cubixli_delete_disk

function cubixli_call(func, args)
    if current_envir ~= 'cubixli' then
        ferror("cubixli_call: cubixli env not loaded")
        return false
    end
    normal("[cubix:"..func.."]")
    local result = _G['cubixli_'..func](args)
    if result == 0 then return true end
    return false
end

--deldisk util
function deldisk(args)
    if #args == 0 then print("usage: deldisk <disk>") return 0 end
    if _prompt("Do you want to delete your disk?", "Y", "n") then
        if cubixli_call("delete_disk", args) then
            print("deldisk: deleted /")
        else
            ferror("deldisk: error doing delete_disk")
        end
    else
        return 0
    end
end

--lsblk binary
function lsblk()
    for k,vl in pairs(current_disks) do
        write(k..':\n')
        for _, v in pairs(vl) do
            write("  "..v[1].." type "..v[2].." mounted in "..v[3]..'\n')
        end
    end
    write('\n')
    return 0
end

--yapstrap binary
function run_build_hook(hook)
    if hook == 'initramfs' then
        if os.loadAPI("/boot/libcubix") then
            libcubix.generate_lcubix('all', '/boot/cubix-initramfs')
        else
            ferror("error loading libcubix.")
        end
    else
        ferror("build hook not found")
    end
end

function yapstrap(args)
    if current_envir ~= 'cubixli' then
        ferror("yapstrap: cubixli env not loaded")
        return 1
    end
    if #args == 0 then print("usage: yapstrap <task>") return 0 end
    for k,v in pairs(args) do
        if v == 'cubix' then
            shellcmd("yapi -Sy")
            shellcmd("yapi -S base")
            shell.run("FINISHINSTALL")
            local handler = fs.open("/tmp/install_lock", 'w')
            handler.close()
            normal("created /tmp/install_lock")
            normal("running build hook: initramfs")
            run_build_hook('initramfs')
            normal("yapstrap: finished "..v.." task")
        end
    end
    return 0
end

--ls binary
local chars = {}
for i = 32, 126 do chars[string.char(i)] = i end

local function sortingComparsion(valueA, valueB)
    local strpos = 0
    local difference = 0
    while strpos < #valueA and strpos < #valueB and difference == 0 do
        strpos = strpos + 1
        if chars[string.sub(valueA, strpos, strpos)] > chars[string.sub(valueB, strpos, strpos)] then
            difference = 1
        elseif chars[string.sub(valueA, strpos, strpos)] < chars[string.sub(valueB, strpos, strpos)] then
            difference = -1
        end
    end
    if difference == -1 then
        return true
    else
        return false
    end
end

function _ls(pth)
    local nodes = fs.list(pth)
    local files = {}
    local folders = {}
    for k,v in ipairs(nodes) do
        if fs.isDir(pth..'/'..v) then
            table.insert(folders, v)
        else
            table.insert(files, v)
        end
    end
    table.sort(folders, sortingComparsion)
    table.sort(files, sortingComparsion)
    --printing folders
    term.set_term_color(colors.green)
    for k,v in ipairs(folders) do
        write(v..' ')
    end
    term.set_term_color(colors.white)
    --printing files
    for k,v in ipairs(files) do
        write(v..' ')
    end
    write('\n')
end

function ls(args)
    local p = args[1]
    if p == nil then
        _ls(current_path)
    elseif fs.exists(p) then
        _ls(p)
    elseif fs.exists(fs.combine(current_path, p)) then
        _ls(fs.combine(current_path, p))
    end
end

--cd binary
function pth_goup(p)
    elements = strsplit(p, '/')
    res = ''
    for i = 1, (#elements - 1) do
        print(res)
        res = res .. '/' .. elements[i]
    end
    return res
end

function _cd(pth)
    local CURRENT_PATH = current_path
    if CURRENT_PATH == nil then
        CURRENT_PATH = '/'
    elseif pth == '.' then
        CURRENT_PATH = CURRENT_PATH
    elseif pth == '..' then
        CURRENT_PATH = pth_goup(CURRENT_PATH)
    elseif pth == '/' then
        CURRENT_PATH = pth
    elseif fs.exists(CURRENT_PATH .. '/' .. pth) == true then
        CURRENT_PATH = CURRENT_PATH .. '/' .. pth
    elseif fs.exists(pth) == true then
        CURRENT_PATH = pth
    elseif pth == nil then
        --CURRENT_PATH = "/home/"..current_user
    else
        print("cd: not found!")
    end
    return CURRENT_PATH
end

function cd(args)
    local pth = args[1]
    local npwd = _cd(pth)
    current_path = npwd
end

--"cat"ing
function cat(args)
    if #args == 0 then print("usage: cat <absolute path>") return 0 end
    local file = args[1]
    if fs.exists(file) then
        local f = fs.open(file, 'r')
        local data = f.readAll()
        f.close()
        print(data)
        return 0
    else
        ferror("cat: file not found")
        return 1
    end
end

--interface for rebooting
function front_reboot(args)
    if current_envir == 'cubixli' then
        ferror("front_reboot: cannot reboot with cubixli enviroment loaded, please use unloadenv")
        return 1
    end
    print("[cubixli:front_reboot] sending RBT")
    os.sleep(1.5)
    os.reboot()
end

--interface for "shutdowning"
function front_shutdown(args)
    if current_envir == 'cubixli' then
        ferror("front_shutdown: cannot reboot with cubixli enviroment loaded, please use unloadenv")
        return 1
    end
    print("[cubixli:front_shutdown] sending HALT")
    os.sleep(1.5)
    os.shutdown()
end

--set label
function setlabel(args)
    if #args == 0 then print("usage: setlabel <newlabel>") return 0 end
    os.setComputerLabel(tostring(args[1]))
end

--version of cubixLI
function version()
    print("CubixLI "..VERSION.." in "..BUILD_DATE)
end

--load enviroment for cubix to start
function loadenviroment(args)
    if #args == 0 then return 0 end
    normal("[cubixli:loadenviroment] loading "..tostring(args[1]))
    current_envir = tostring(args[1])
end

--unload enviroment
function unloadenv()
    normal("[cubixli:unloadenv] unloading current enviroment ")
    current_envir = ''
end

--sethostname binary
function sethostname(args)
    if current_envir ~= 'cubixli' then
        ferror("sethostname: cubixli enviroment not loaded")
        return 1
    end
    local nhostname = tostring(args[1])
    normal("[cubixli:sethostname] setting hostname to "..nhostname)
    local hostname_handler = fs.open("/etc/hostname", 'w')
    hostname_handler.write(nhostname)
    hostname_handler.close()
    return 0
end

function sbl_bcfg(args)
    local default = fs.open("/boot/sblcfg/default.cfg", 'r')
    local systems = fs.open("/boot/sblcfg/systems.cfg", 'w')
    systems.write(default.readAll())
    default.close()
    systems.close()
    print("sbl-bcfg: systems.cfg restored to default.cfg")
end

function timesetup(args)
    local timeservers = fs.open("/etc/time-servers", 'w')
    for k,v in ipairs(args) do
        timeservers.write(v..'\n')
    end
    timeservers.close()
end

--install help
function insthelp()
    print([[
Installing cubix:
    loadenv cubixli
    lsblk
    deldisk hdd
    yapstrap cubix
    genfstab /etc/fstab
    setlabel <your label here>
    sethostname <your hostname here>
    timesetup <server 1> <server 2> ...
    sbl-bcfg
    unloadenv
    reboot
]])
    return 0
end

function runpath(args)
    --PLEASE DONT USE THIS
    os.run({}, args[1], unpack(tail(args)))
end

function override_shell()
    write("command to run with override=true: ")
    local cmd = read()
    override = true
    shellcmd(cmd)
    override = false
    return 0
end

function genfstab(args)
    local file = args[1]
    local fh = fs.open(file, 'w')
    --device;mountpoint;fs;options;\n
    fh.write("/dev/hda;/;cfs;;\n")
    fh.write("/dev/loop1;/dev/shm;tmpfs;;\n")
    fh.close()
    print("genfstab: generated fstab in "..file)
end

os.tail = function(t)
    if # t <= 1 then
        return nil
    end
    local newtable = {}
    for i, v in ipairs(t) do
        if i > 1 then
            table.insert(newtable, v)
        end
    end
    return newtable
end

os.strsplit = function (inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    if type(inputstr) ~= 'string' then
        os.ferror("os.strsplit: type(inputstr) == "..type(inputstr))
        return 1
    end
    if inputstr == nil then
        return ''
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        t[i] = str
        i = i + 1
    end
    return t
end

os.ferror = ferror

function yapi(args)
    if current_envir ~= 'cubixli' then
        ferror("yapi: cannot run without cubixli enviroment loaded")
        return 1
    end
    VERSION = '0.1.1'

    --defining some things
    local SERVERIP = 'lkmnds.github.io'
    local SERVERDIR = '/yapi'
    local YAPIDIR = '/var/yapi'

    function download_file(url)
        local cache = os.strsplit(url, '/')
        local fname = cache[#cache]
        print('requesting ' .. fname)
        http.request(url)
        local req = true
        while req do
            local e, url, stext = os.pullEvent()
            if e == 'http_success' then
                local rText = stext.readAll()
                stext.close()
                return rText
            elseif e == 'http_failure' then
                req = false
                return {false, 'http_failure'}
            end
        end
    end

    function success(msg)
        term.set_term_color(colors.green)
        print(msg)
        term.set_term_color(colors.white)
    end

    function cache_file(data, filename)
        local h = fs.open(YAPIDIR..'/cache/'..filename, 'w')
        h.write(data)
        h.close()
        return 0
    end

    function isin(inputstr, wantstr)
        for i = 1, #inputstr do
            local v = string.sub(inputstr, i, i)
            if v == wantstr then return true end
        end
        return false
    end

    function create_default_struct()
        fs.makeDir(YAPIDIR.."/cache")
        fs.makeDir(YAPIDIR.."/db")
        fs.open(YAPIDIR..'/installedpkg', 'a').close()
    end

    function update_repos()
        --download core, community and extra
        local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/core'
        local k = download_file(SPATH)
        if type(k) == 'table' then
            ferror("yapi: http error")
            return 1
        end
        local _h = fs.open(YAPIDIR..'/db/core', 'w')
        _h.write(k)
        _h.close()
        local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/community'
        local k = download_file(SPATH)
        if type(k) == 'table' then
            ferror("yapi: http error")
            return 1
        end
        local _h = fs.open(YAPIDIR..'/db/community', 'w')
        _h.write(k)
        _h.close()
        local SPATH = 'http://'.. SERVERIP .. SERVERDIR .. '/database/extra'
        local k = download_file(SPATH)
        if type(k) == 'table' then
            ferror("yapi: http error")
            return 1
        end
        local _h = fs.open(YAPIDIR..'/db/extra', 'w')
        _h.write(k)
        _h.close()
    end

    --Yapi Database
    yapidb = {}
    yapidb.__index = yapidb
    function yapidb.new(path)
        local inst = {}
        setmetatable(inst, yapidb)
        inst.path = path
        inst.db = ''
        return inst
    end

    function yapidb:update()
        self.db = ''
        self.db = self.db .. '\n'
        local h = fs.open(self.path..'/core', 'r')
        local _k = h.readAll()
        self.db = self.db .. _k
        h.close()
        self.db = self.db .. '\n'
        local h = fs.open(self.path..'/community', 'r')
        local _k = h.readAll()
        self.db = self.db .. '\n'
        self.db = self.db .. _k
        h.close()
        self.db = self.db .. '\n'
        local h = fs.open(self.path..'/extra', 'r')
        local _k = h.readAll()
        self.db = self.db .. '\n'
        self.db = self.db .. _k
        self.db = self.db .. '\n'
        h.close()
    end

    function yapidb:search(pkgname)
        self:update()
        local _lines = self.db
        local lines = os.strsplit(_lines, '\n')
        for k,v in pairs(lines) do
            local pkgdata = os.strsplit(v, ';')
            if pkgdata[1] == pkgname then
                return {true, v}
            end
        end
        return {false, nil}
    end

    function yapidb:search_wcache(pkgname)
        self:update()
        if fs.exists(YAPIDIR..'/cache/'..pkgname..'.yap') then
            local h = fs.open(YAPIDIR..'/cache/'..pkgname..'.yap', 'r')
            local f = h.readAll()
            h.close()
            return f
        else
            local _url = self:search(pkgname)
            local url = os.strsplit(_url[2], ';')[2]
            local yapdata = download_file(url)
            if type(yapdata) == 'table' then return -1 end
            cache_file(yapdata, pkgname..'.yap')
            return yapdata
        end
    end

    --parsing yap files
    function parse_yap(yapf)
        local lines = os.strsplit(yapf, '\n')
        local yapobject = {}
        yapobject['folders'] = {}
        yapobject['files'] = {}
        yapobject['deps'] = {}
        if type(lines) ~= 'table' then
            os.ferror("::! [parse_yap] type(lines) ~= table")
            return 1
        end
        local isFile = false
        local rFile = ''
        for _,v in pairs(lines) do
            if isFile then
                local d = v
                if d ~= 'EndFile;' then
                    if yapobject['files'][rFile] == nil then
                        yapobject['files'][rFile] = d .. '\n'
                    else
                        yapobject['files'][rFile] = yapobject['files'][rFile] .. d .. '\n'
                    end
                else
                    isFile = false
                    rFile = ''
                end
            end
            local splitted = os.strsplit(v, ';')
            if splitted[1] == 'Name' then
                yapobject['name'] = splitted[2]
            elseif splitted[1] == 'Version' then
                yapobject['version'] = splitted[2]
            elseif splitted[1] == 'Build' then
                yapobject['build'] = splitted[2]
            elseif splitted[1] == 'Author' then
                yapobject['author'] = splitted[2]
            elseif splitted[1] == 'Email-Author' then
                yapobject['email_author'] = splitted[2]
            elseif splitted[1] == 'Description' then
                yapobject['description'] = splitted[2]
            elseif splitted[1] == 'Folder' then
                table.insert(yapobject['folders'], splitted[2])
            elseif splitted[1] == 'File' then
                isFile = true
                rFile = splitted[2]
            elseif splitted[1] == 'Dep' then
                table.insert(yapobject['deps'], splitted[2])
            end
        end
        return yapobject
    end

    function yapidb:installed_pkgs()
        local handler = fs.open(YAPIDIR..'/installedpkg', 'r')
        local file = handler.readAll()
        handler.close()
        local lines = os.strsplit(file, '\n')
        return lines
    end

    function yapidb:is_installed(namepkg)
        local installed = self:installed_pkgs()
        for k,v in ipairs(installed) do
            local splitted = os.strsplit(v, ';')
            if splitted[1] == namepkg then return true end
        end
        return false
    end

    function yapidb:updatepkgs()
        self:update()
        for k,v in pairs(self:installed_pkgs()) do
            local pair = os.strsplit(v, ';')
            local w = self:search(pair[1])
            local yd = {}
            if w[1] == false then
                os.ferror("::! updatepkgs: search error")
                return false
            end
            local url = os.strsplit(w[2], ';')[2]
            local rawdata = download_file(url)
            if type(rawdata) == 'table' then
                os.ferror("::! [install] type(rawdata) == table : "..yapfile[2])
                return false
            end
            local yd = parse_yap(rawdata)
            if tonumber(pair[2]) < tonumber(yd['build']) then
                print(" -> new build of "..pair[1].." ["..pair[2].."->"..yd['build'].."] ")
                self:install(pair[1]) --install latest
            else
                print(" -> [updatepkgs] "..yd['name']..": OK")
            end
        end
    end

    function yapidb:register_pkg(yapdata)
        print("==> [register] "..yapdata['name'])
        local _h = fs.open(YAPIDIR..'/installedpkg', 'r')
        local _tLines = _h.readAll()
        _h.close()
        local pkg_found = false
        local tLines = os.strsplit(_tLines, '\n')
        for k,v in ipairs(tLines) do
            local pair = os.strsplit(v, ';')
            if pair[1] == yapdata['name'] then
                pkg_found = true
                tLines[k] = yapdata['name']..';'..yapdata['build']
            else
                tLines[k] = tLines[k] .. '\n'
            end
        end
        if not pkg_found then
            tLines[#tLines+1] = yapdata['name']..';'..yapdata['build'] .. '\n'
        end

        print(" -> writing to file")
        local h2 = fs.open(YAPIDIR..'/installedpkg', 'w')
        for k,v in pairs(tLines) do
            h2.write(v)
        end
        h2.close()
    end

    function yapidb:install_yap(yapdata)
        print("==> install_yap: "..yapdata['name'])
        for k,v in pairs(yapdata['folders']) do
            fs.makeDir(v)
        end
        for k,v in pairs(yapdata['files']) do
            local h = fs.open(k, 'w')
            h.write(v)
            h.close()
        end
        return true
    end

    function yapidb:return_dep_onepkg(pkgname)
        local _s = self:search(pkgname)
        if _s[1] == true then
            local result = os.strsplit(_s[2], ';')
            local yapfile = download_file(result[2])
            if type(yapfile) == 'table' then
                os.ferror("::! [getdep] "..yapfile[2])
                return false
            end
            cache_file(yapfile, pkgname..'.yap')
            local yapdata = parse_yap(yapfile)
            local dependencies = {}
            if yapdata['deps'] == nil then
                print(" -> no dependencies: "..pkgname)
                return {}
            end
            for _,dep in ipairs(yapdata['deps']) do
                table.insert(dependencies, dep)
            end
            return dependencies
        else
            return false
        end
    end

    function yapidb:return_deps(pkglist)
        local r = {}
        for _,pkg in ipairs(pkglist) do
            local c = self:return_dep_onepkg(pkg)
            if c == false then
                ferror("::! [getdeps] error getting deps: "..pkg)
                return 1
            end
            for i=0,#c do
                table.insert(r, c[i])
            end
            table.insert(r, pkg)
        end
        return r
    end

    function yapidb:install(pkgname)
        local _s = self:search(pkgname)
        if _s[1] == true then
            local result = os.strsplit(_s[2], ';')
            local yapfile = download_file(result[2])
            if type(yapfile) == 'table' then
                os.ferror("::! [install] "..yapfile[2])
                return false
            end
            cache_file(yapfile, pkgname..'.yap')
            local yapdata = parse_yap(yapfile)
            local missing_dep = {}
            if yapdata['deps'] == nil or pkgname == 'base' then
                print(" -> no dependencies: "..pkgname)
            else
                for _,dep in ipairs(yapdata['deps']) do
                    if not self:is_installed(dep) then
                        table.insert(missing_dep, dep)
                    end
                end
            end
            if #missing_dep > 0 then
                ferror("error: missing dependencies")
                for _,v in ipairs(missing_dep) do
                    write(v..' ')
                end
                write('\n')
                return false
            end
            self:register_pkg(yapdata)
            self:install_yap(yapdata)
            return true
        else
            os.ferror("error: target not found: "..pkgname)
            return false
        end
    end

    function yapidb:remove(pkgname)
        --1st: read cached yapdata
        --2nd: remove all files made by yapdata['files']
        --3rd: remove entry in YAPIDIR..'/installedpkg'
        if not self:is_installed(pkgname) then
            os.ferror(" -> package not installed")
            return false
        end
        local yfile = self:search_wcache(pkgname)
        local ydata = parse_yap(yfile)
        --2nd part
        print("==> remove: "..ydata['name'])
        for k,v in pairs(ydata['files']) do
            fs.delete(k)
        end
        for k,v in pairs(ydata['folders']) do
            fs.delete(v)
        end

        local _h = fs.open(YAPIDIR..'/installedpkg', 'r')
        local _tLines = _h.readAll()
        _h.close()
        local pkg_found = false
        local tLines = os.strsplit(_tLines, '\n')
        for k,v in ipairs(tLines) do
            local pair = os.strsplit(v, ';')
            if pair[1] == ydata['name'] then
                tLines[k] = '\n'
            else
                tLines[k] = tLines[k] .. '\n'
            end
        end

        local h2 = fs.open(YAPIDIR..'/installedpkg', 'w')
        for k,v in pairs(tLines) do
            h2.write(v)
        end
        h2.close()
        return true
    end

    function yapidb:clear_cache()
        fs.delete(YAPIDIR..'/cache')
        fs.makeDir(YAPIDIR..'/cache')
    end

    function main(args)
        create_default_struct()
        if #args == 0 then
            print("usage: yapi <mode> ...")
        else
            --print("yapi "..VERSION)
            local option = args[1]
            if string.sub(option, 1, 1) == '-' then
                if string.sub(option, 2,2) == 'S' then
                    local packages = os.tail(args)
                    if packages ~= nil then
                        local database = yapidb.new(YAPIDIR..'/db')
                        database:update()
                        for k,pkg in ipairs(packages) do
                            if not database:search(pkg)[1] then
                                os.ferror("error: target not found: "..pkg)
                                return 1
                            end
                        end
                        print("resolving dependencies...")
                        packages = database:return_deps(packages)
                        print("")
                        write("Packages ("..#packages..") ")
                        for _,pkg in ipairs(packages) do
                            write(pkg..' ')
                        end
                        print("\n")
                        if not prompt(":: Proceed with installation?", "Y", "n") then
                            print("==> Aborted")
                            return true
                        end
                        for k,package in ipairs(packages) do
                            --local database = yapidb.new(YAPIDIR..'/db')
                            --database:update()
                            --print("==> [install] "..package)
                            print(":: Installing packages ...")
                            local completed = 1
                            if database:install(package) then
                                success("("..completed.."/"..tostring(#packages)..")"..package.." : SUCCESS")
                                completed = completed + 1
                            else
                                --os.ferror("==> "..package.." : FAILURE")
                                return 1
                            end
                        end
                    end

                    if isin(option, 'c') then
                        local database = yapidb.new(YAPIDIR..'/db')
                        print("==> [clear_cache]")
                        database:clear_cache()
                    end

                    if isin(option, 'y') then
                        print(":: Update from "..SERVERIP)
                        if not http then
                            os.ferror("yapi: http not enabled")
                            return 1
                        end
                        update_repos()
                    end

                    if isin(option, 'u') then
                        local database = yapidb.new(YAPIDIR..'/db')
                        print(":: Starting full system upgrade")
                        if prompt("Confirm full system upgrade", "Y", "n") then
                            database:updatepkgs()
                        else
                            print("==> Aborted")
                        end
                    end
                elseif string.sub(option,2,2) == 'U' then
                    local yfile = fs.combine(current_path, args[2])
                    print("==> [install_yap] "..yfile)
                    local h = fs.open(yfile, 'r')
                    local _data = h.readAll()
                    h.close()
                    local ydata = parse_yap(_data)
                    local database = yapidb.new(YAPIDIR..'/db')
                    if database:install_yap(ydata) then
                        success("==> [install_yap] "..ydata['name'])
                    else
                        os.ferror("::! [install_yap] "..ydata['name'])
                    end
                elseif string.sub(option,2,2) == 'Q' then
                    local database = yapidb.new(YAPIDIR..'/db')
                    local pkg = args[2]
                    local _k = database:search(pkg)
                    if pkg then
                        if _k[1] == true then
                            local _c = database:search_wcache(pkg)
                            local yobj = parse_yap(_c)
                            if type(yobj) ~= 'table' then
                                os.ferror("::! [list -> parse_yap] error (yobj ~= table)")
                                return 1
                            end
                            print(yobj.name .. ' ' .. yobj.build .. ':' .. yobj.version)
                            print("Maintainer: "..yobj.author.." <"..yobj['email_author']..">")
                            print("Description: "..yobj.description)
                        else
                            os.ferror("::! package not found")
                        end
                    end
                    if isin(option, 'e') then
                        local database = yapidb.new(YAPIDIR..'/db')
                        database:update()
                        --print("Installed packages: ")
                        local ipkg = database:installed_pkgs()
                        for _,ntv in ipairs(ipkg) do
                            local v = os.strsplit(ntv, ';')
                            write(v[1] .. ':' .. v[2] .. '\n')
                        end
                    end
                elseif string.sub(option,2,2) == 'R' then
                    local packages = os.tail(args)
                    if packages ~= nil then
                        local database = yapidb.new(YAPIDIR..'/db')
                        database:update()
                        for k,pkg in ipairs(packages) do
                            if not database:search(pkg)[1] then
                                os.ferror("error: target not found: "..pkg)
                                return 1
                            end
                        end
                        if not prompt("Proceed with remotion?", "Y", "n") then
                            print("==> Aborted")
                            return true
                        end
                        for k,package in ipairs(packages) do
                            --local database = yapidb.new(YAPIDIR..'/db')
                            --database:update()
                            print(":: removing "..package)
                            if database:remove(package) then
                                success("==> [remove] "..package.." : SUCCESS")
                            else
                                os.ferror("::! [remove] "..package.." : FAILURE")
                                return 1
                            end
                        end
                    end
                end
            else
                os.ferror("yapi: sorry, see \"man yapi\" for details")
            end
        end
    end
    main(args)
end

local SHELLCMD = {}
SHELLCMD['ls'] = ls
SHELLCMD['cd'] = cd
SHELLCMD['yapstrap'] = yapstrap
SHELLCMD['deldisk'] = deldisk
SHELLCMD['setlabel'] = setlabel
SHELLCMD['loadenv'] = loadenviroment
SHELLCMD['unloadenv'] = unloadenv
SHELLCMD['version'] = version
SHELLCMD['help'] = insthelp
SHELLCMD['reboot'] = front_reboot
SHELLCMD['shutdown'] = front_shutdown
SHELLCMD['run'] = runpath
SHELLCMD['lsblk'] = lsblk
SHELLCMD['sethostname'] = sethostname
SHELLCMD['cat'] = cat
SHELLCMD['override'] = override_shell
SHELLCMD['sbl-bcfg'] = sbl_bcfg
SHELLCMD['timesetup'] = timesetup
SHELLCMD['genfstab'] = genfstab
SHELLCMD['yapi'] = yapi

function list_cmds(args)
    print("Available commands:")
    for k,v in pairs(SHELLCMD) do
        write(k..' ')
    end
    write('\n')
end

SHELLCMD['cmds'] = list_cmds

function shellcmd(cmd)
    local k = strsplit(cmd, ' ')
    local _args = tail(k)
    if _args == nil then _args = {} end
    if SHELLCMD[k[1]] ~= nil then
        SHELLCMD[k[1]](_args)
    else
        ferror("clish: command not found")
    end
end

function run_shell()
    --THIS IS NOT CSHELL!!!!11!!!ELEVEN!!
    local command = ""
    local shell_char = '# '
    local current_user = 'root'
    local HISTORY = {}
    while true do
        write(current_user .. ':' .. current_path .. shell_char)
        command = read(nil, HISTORY)
        table.insert(HISTORY, command)
        if command == "exit" then
            return 0
        elseif command ~= nil then
            shellcmd(command)
        end
    end
    return 0
end

function main()
    if _G["IS_CUBIX"] then
        ferror("cubixli: in cubix, cubixli must run as root")
        return 0
    end
    load_env()
    run_shell()
end

if not IS_CUBIX then
    main()
end
