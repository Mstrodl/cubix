#!/usr/bin/env lua
--/boot/cubix: well, cubix!

AUTHOR = "Lukas Mendes"
BUILD_DATE = "2015-12-28"

--  version format: major.revision.minor
--      major: linear
--      revision: odd: unstable
--      revision: even: stable
--      minor: number of RELEASES necessary to get to this version, not including BUILDS
--  0.3.8 < 0.3.9 < 0.3.10 < 0.3.11 < 0.4.0 < 0.4.1 [...]
--  {           UNSTABLE           }  {  STABLE   }
VERSION_MAJOR = 0
VERSION_REV   = 5
VERSION_MINOR = 1
VERSION = VERSION_MAJOR.."."..VERSION_REV.."."..VERSION_MINOR

STABLE = ((VERSION_REV % 2) == 0)

if STABLE then
    local pullEvent = os.pullEvent
    os.pullEvent = os.pullEventRaw
else
    print("[cubix] warning, loading a unstable")
end

_G['IS_CUBIX'] = true

--frontend for compatibility
term.set_term_color = function (c)
    if term.isColor() then
        term.setTextColor(c)
    end
end

os.viewTable = function (t)
    if t == nil then return 0 end
    print(t)
    for k,v in pairs(t) do
        print(k..","..tostring(v).." ("..type(v)..")")
    end
end

os.tail = function(t)
    if # t <= 1 then
        return nil
    end
    local newtable = {}
    for i, v in ipairs(t) do
        if i > 1 then
            table.insert(newtable, v)
        end
    end
    return newtable
end

local Args = {...} --arguments to cubix

os.__boot_flag = true

os.strsplit = function (inputstr, sep)
    if sep == nil then
        sep = "%s"
    end
    if type(inputstr) ~= 'string' then
        os.ferror("os.strsplit: type(inputstr) == "..type(inputstr))
        return 1
    end
    if inputstr == nil then
        return ''
    end
    local t={} ; i=1
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
        t[i] = str
        i = i + 1
    end
    return t
end

kflag = {}

for k,v in ipairs(Args) do
    if v == 'quiet' then
        kflag.quiet = true
    elseif v == 'nodebug' then
        kflag.nodebug = true
    elseif v == 'splash' then
        kflag.splash = true
    elseif v == 'acpi' then
        kflag.acpi = true
    elseif string.sub(v, 0, 4) == 'init' then
        k = os.strsplit(v, '=')
        kflag.init = k[2]
    elseif string.sub(v, 0, 8) == 'runlevel' then
        k = os.strsplit(v, '=')
        kflag.sRunlevel = k[2]
    end
end

if kflag.init == nil then
    kflag.init = "/sbin/init"
end

os.__kflag = kflag

local pcid = fs.open("/var/pcid", 'w')
local _label = os.getComputerLabel()
if _label == nil then _label = 'generic' end
pcid.write(_label)
pcid.close()

local version = fs.open("/proc/version", 'w')
version.write(VERSION)
version.close()

local build = fs.open("/proc/build_date", 'w')
build.write(BUILD_DATE)
build.close()

local sttime = fs.open("/proc/sttime", 'w')
sttime.write(tostring(os.time()))
sttime.close()

DEVICES = {}
MANAGED_FILES = {}
TTYS = {}

os.list_mfiles = {}

os.system_halt = function()
    while true do sleep(0) end
end

os._read = read
os._sleep = os.sleep

os.runfile = function(cmd)
    os.ferror("[cubix_deprecated] Sorry, os.runfile is marked as bad code and will not be in this cubix")
    return -1
end

os.ferror = function(message)
    --TODO: stdin, stdout and stderr
    --[[
    device_write("/dev/stderr", message)
    ]]
    term.set_term_color(colors.red)
    print(message)
    term.set_term_color(colors.white)
end

_G['ferror'] = os.ferror

os.safestr = function (s)
    if string.byte(s) > 191 then
        return '@'..string.byte(s)
    end
    return s
end

os.generateSalt = function(l)
    if l < 1 then
        return nil
    end
    local res = ''
    for i = 1, l do
        res = res .. string.char(math.random(32, 126))
    end
    return res
end

function _prompt(message, yes, nope)
    write(message..'['..yes..'/'..nope..'] ')
    local result = read()
    if result == yes then
        return true
    else
        return false
    end
end

_G['prompt'] = _prompt

if os.loadAPI("/lib/video_manager") then
    print("loaded video")
end

if os.loadAPI("/lib/debug_manager") then
    debug = _G["debug_manager"]
    debug.debug_write("debug: loaded")
else
    debug.debug_write = print
    term.set_term_color(colors.red)
    debug.debug_write("debug: not loaded")
    term.set_term_color(colors.white)
end

if kflag.quiet then
    debug.debug_write = function()end
    debug.testcase = function()end
    debug.ferror = function()end
end

os.debug = debug

term.set_term_color(colors.green)
debug.debug_write("Welcome to Cubix "..VERSION..'!')
os.sleep(.5)

os.lib = {}
os.internals = {}
os.internals._kernel = {}

local isReloadable = {}

function loadmodule(nmodule, path)
    os.debug.debug_write('[mod] loading: '..nmodule)
    if isReloadable[nmodule] ~= nil and isReloadable[nmodule] == false then
        os.debug.debug_write("[mod] cannot reload "..nmodule..", please reboot!", nil, true)
        return 0
    end
    if os.loadAPI(path) then
        _G[nmodule] = _G[fs.getName(path)]
        if _G[nmodule].libroutine ~= nil then
            _G[nmodule].libroutine()
        else
            os.debug.debug_write("[mod] libroutine() not found", nil, true)
            sleep(.3)
        end
        os.lib[nmodule] = _G[fs.getName(path)]
        isReloadable[nmodule] = os.lib[nmodule].RELOADABLE
        os.debug.debug_write('[mod] loaded: '..nmodule)
    else
        os.debug.kpanic("[mod] not loaded: "..nmodule)
    end
end

function loadmodule_ret(path)
    os.debug.debug_write('[loadmodule:ret] loading: '..path)
    local ret = {}
    if os.loadAPI(path) then
        ret = _G[fs.getName(path)]
        if ret.libroutine ~= nil then
            ret.libroutine()
        else
            os.debug.debug_write("[loadmodule:ret] libroutine() not found", nil, true)
            sleep(.3)
        end
        os.debug.debug_write('[loadmodule:ret] loaded: '..path)
        return ret
    else
        ferror("[loadmodule:ret] not loaded: "..path)
    end
end

os.internals.loadmodule = loadmodule

function os.viewLoadedMods()
    for k,v in pairs(os.lib) do
        write(k..' ')
    end
    write('\n')
end

--hack
os.lib.proc = {}
os.lib.proc.running = 0
os.processes = {}

function make_readonly(table)
    local temporary = {}
    setmetatable(temporary, {
        __index = table,
        __newindex = function(_t, k, v)
            local runningproc = os.processes[os.lib.proc.running]
            if runningproc == nil then
                os.debug.debug_write("[readonly -> proc] cubix is not running any process now!", nil, true)
                table[k] = v
                return 0
            end
            if runningproc.uid ~= 0 then
                os.debug.debug_write("[readonly] Attempt to modify read-only table", nil, true)
            else
                table[k] = v
            end
        end,
        __metatable = false
    })
    os.debug.debug_write("[readonly] new read-only table!")
    return temporary
end

_G['make_readonly'] = make_readonly

--acpi module
if kflag.acpi then
    loadmodule("acpi", "/lib/acpi.lua")
end

--another hack
os.lib.login = {}
os.lib.login.currentUser = function()
    return {uid = 2}
end

--filesystem manager
loadmodule("fs_mngr", "/lib/fs_manager")

permission.initKernelPerm()

if fs.exists("/dev/ram") and os.lib.acpi then
    os.lib.acpi.acpi_hwake()
else

--process manager
function os.internals._kernel.register_mfile(controller)
    debug.debug_write("[mfile] "..controller.name.." created")
    os.list_mfiles[controller.name] = controller.file
    fs.open(controller.name, 'w', fs.perms.SYS).close()
end

loadmodule("proc", "/lib/proc_manager")

--hash manager
loadmodule("hash", "/lib/hash_manager")

function os.internals._kernel.register_device(d)
    os.debug.debug_write("[dev] "..d.name.." created")
    DEVICES[d.name] = d.device
    fs.open(d.name, 'w', fs.perms.SYS).close()
end

--device manager
loadmodule("devices", "/lib/device_manager")

--external devices
function from_extdev(name_dev, path_dev, type_dev)
    --path_dev -> /dev/
    --name -> only a id
    --type_dev -> device drivers(something.lua)
    --returns a table with the device methods(read, devwrite)
    local devmod = loadmodule_ret("/lib/devices/"..type_dev..".lua")
    devmod.setup(name_dev, path_dev)
    return devmod
end

EXTDEVICES = {}
function os.internals._kernel.new_device(typedev, name, pth)
    os.debug.debug_write("[extdev] "..name.." ("..typedev..") -> "..pth)
    EXTDEVICES[name] = {devtype=typedev, path=pth}
    os.internals._kernel.register_device({name=pth, device=from_extdev(name,pth,typedev)})
end

--default devices
os.internals._kernel.new_device("kbd", "cckbd", "/dev/stdin")
os.internals._kernel.new_device("term", "ccterm", "/dev/stdout")
os.internals._kernel.new_device("err", "ccterm-err", "/dev/stderr")

os.list_devices = fs_mngr.deepcopy(DEVICES)
function dev_write(path, data)
    return os.list_devices[path].device_write(data)
end
_G['dev_write'] = dev_write

function dev_read(path, bytes)
    local result = os.list_devices[path].device_read(bytes)
    return result
end
_G['dev_read'] = dev_read

function dev_available(path)
    local av = os.list_devices[path] ~= nil
    return av
end
_G['dev_available'] = dev_available

function get_device(pth)
    return os.list_devices[pth]
end
_G['get_device'] = get_device

function os.list_dev()
    for k,v in pairs(os.list_devices) do
        write(k..' ')
    end
    write('\n')
end

local perilist = peripheral.getNames()
os.debug.debug_write("[peripheral] begin detection")
for i = 1, #perilist do
    os.internals._kernel.new_device("peripheral", tostring(peripheral.getType(perilist[i])))
end

--tty, login and pipe managers
function os.internals._kernel.register_tty(path, tty)
    os.debug.debug_write("[tty] new tty: "..path)
    TTYS[path] = tty
    fs.open(path, 'w', fs.perms.SYS).close()
end

loadmodule("tty", "/lib/tty_manager")
loadmodule("login", "/lib/login_manager")
loadmodule("pipe", "/lib/pipe_manager")
loadmodule("time", "/lib/time")

os.pprint = function(message, pipe, double)
    if double == nil then double = false end
    if message == nil then message = '' end
    if pipe ~= nil then
        pipe:write(message..'\n')
        if double then
            print(message)
        end
    else
        print(message)
    end
end

term.clear()
term.setCursorPos(1,1)

--finishing boot
os.__debug_buffer = debug.__debug_buffer
os.__boot_flag = false

--setting tty
os.lib.tty.current_tty("/dev/tty1")

--finally, run!
os.__parent_init = os.new_process(kflag.init)
if kflag.sRunlevel ~= nil then
    os.run_process(os.__parent_init, {kflag.sRunlevel})
else
    os.run_process(os.__parent_init)
end

--if something goes wrong in kflag.init, just halt
os.system_halt()

end
